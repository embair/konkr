{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "node_modules/browserify/node_modules/buffer/index.js",
    "node_modules/browserify/node_modules/buffer/node_modules/base64-js/index.js",
    "node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js",
    "node_modules/browserify/node_modules/buffer/node_modules/isarray/index.js",
    "node_modules/browserify/node_modules/process/browser.js",
    "node_modules/expect/lib/Expectation.js",
    "node_modules/expect/lib/SpyUtils.js",
    "node_modules/expect/lib/TestUtils.js",
    "node_modules/expect/lib/assert.js",
    "node_modules/expect/lib/extend.js",
    "node_modules/expect/lib/index.js",
    "node_modules/expect/node_modules/define-properties/index.js",
    "node_modules/expect/node_modules/define-properties/node_modules/foreach/index.js",
    "node_modules/expect/node_modules/has/node_modules/function-bind/implementation.js",
    "node_modules/expect/node_modules/has/node_modules/function-bind/index.js",
    "node_modules/expect/node_modules/has/src/index.js",
    "node_modules/expect/node_modules/is-equal/getCollectionsForEach.js",
    "node_modules/expect/node_modules/is-equal/getSymbolIterator.js",
    "node_modules/expect/node_modules/is-equal/node_modules/is-arrow-function/index.js",
    "node_modules/expect/node_modules/is-equal/node_modules/is-boolean-object/index.js",
    "node_modules/expect/node_modules/is-equal/node_modules/is-callable/index.js",
    "node_modules/expect/node_modules/is-equal/node_modules/is-date-object/index.js",
    "node_modules/expect/node_modules/is-equal/node_modules/is-generator-function/index.js",
    "node_modules/expect/node_modules/is-equal/node_modules/is-number-object/index.js",
    "node_modules/expect/node_modules/is-equal/node_modules/is-string/index.js",
    "node_modules/expect/node_modules/is-equal/node_modules/is-symbol/index.js",
    "node_modules/expect/node_modules/is-equal/why.js",
    "node_modules/expect/node_modules/is-regex/index.js",
    "node_modules/expect/node_modules/object-inspect/index.js",
    "node_modules/expect/node_modules/object-keys/index.js",
    "node_modules/expect/node_modules/object-keys/isArguments.js",
    "node_modules/expect/node_modules/tmatch/index.js",
    "node_modules/loglevel/lib/loglevel.js",
    "node_modules/noisejs/index.js",
    "src\\index.js",
    "src\\lib\\AssetManager.js",
    "src\\lib\\HexGrid.js",
    "src\\lib\\Renderer.js",
    "src\\lib\\WorldGenerator.js",
    "src\\lib\\ui\\TileSelectionProxy.js",
    "src\\lib\\util.js",
    "src\\states\\Play.js"
  ],
  "names": [],
  "mappings": "AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/TA;;;;AACA;;;;AAEA;;;;AAEA;;;;;;;;AAEA;;AAdA;AACA;AACA;AACA;AACA;AACA;;AAUA,I,AAAA,AAAI,MAAc;;AAElB;AACA;AACA,IAAI,I,AAAJ,AAAQ,IAAU;;AAElB;AACA,IAAI,YAAJ,AAAgB;AAChB;AACA,SAAA,AAAS,SAAS,AAAE;WAAO,EAAP,AAAS,AAAY;;;AAEzC;AACA;;AAEA;;AAEA,OAAO,IAAI,OAAJ,AAAW,KAAX,AAAgB,MAAhB,AAAsB,KAAK,OAA3B,AAAkC,MAAzC,AAAO,AAAwC;;AAE/C,IAAI;oBAAM,AAEN;UAFM,AAEA,AACN;eAHJ,AAAU,AAGK;AAHL,AACN;AAIJ,OAAA,AAAO,MAAP,AAAa;;AAEb,IAAA,AAAI,eAAe,2BAAnB,AAAmB,AAAiB;;AAEpC;AACA,mBA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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n",
    "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n",
    "exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n",
    "var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n",
    "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",
    "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _tmatch = require('tmatch');\n\nvar _tmatch2 = _interopRequireDefault(_tmatch);\n\nvar _assert = require('./assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _SpyUtils = require('./SpyUtils');\n\nvar _TestUtils = require('./TestUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * An Expectation is a wrapper around an assertion that allows it to be written\n * in a more natural style, without the need to remember the order of arguments.\n * This helps prevent you from making mistakes when writing tests.\n */\n\nvar Expectation = function () {\n  function Expectation(actual) {\n    _classCallCheck(this, Expectation);\n\n    this.actual = actual;\n\n    if ((0, _TestUtils.isFunction)(actual)) {\n      this.context = null;\n      this.args = [];\n    }\n  }\n\n  _createClass(Expectation, [{\n    key: 'toExist',\n    value: function toExist(message) {\n      (0, _assert2.default)(this.actual, message || 'Expected %s to exist', this.actual);\n\n      return this;\n    }\n  }, {\n    key: 'toNotExist',\n    value: function toNotExist(message) {\n      (0, _assert2.default)(!this.actual, message || 'Expected %s to not exist', this.actual);\n\n      return this;\n    }\n  }, {\n    key: 'toBe',\n    value: function toBe(value, message) {\n      (0, _assert2.default)(this.actual === value, message || 'Expected %s to be %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toNotBe',\n    value: function toNotBe(value, message) {\n      (0, _assert2.default)(this.actual !== value, message || 'Expected %s to not be %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toEqual',\n    value: function toEqual(value, message) {\n      try {\n        (0, _assert2.default)((0, _TestUtils.isEqual)(this.actual, value), message || 'Expected %s to equal %s', this.actual, value);\n      } catch (error) {\n        // These attributes are consumed by Mocha to produce a diff output.\n        error.actual = this.actual;\n        error.expected = value;\n        error.showDiff = true;\n        throw error;\n      }\n\n      return this;\n    }\n  }, {\n    key: 'toNotEqual',\n    value: function toNotEqual(value, message) {\n      (0, _assert2.default)(!(0, _TestUtils.isEqual)(this.actual, value), message || 'Expected %s to not equal %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toThrow',\n    value: function toThrow(value, message) {\n      (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The \"actual\" argument in expect(actual).toThrow() must be a function, %s was given', this.actual);\n\n      (0, _assert2.default)((0, _TestUtils.functionThrows)(this.actual, this.context, this.args, value), message || 'Expected %s to throw %s', this.actual, value || 'an error');\n\n      return this;\n    }\n  }, {\n    key: 'toNotThrow',\n    value: function toNotThrow(value, message) {\n      (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The \"actual\" argument in expect(actual).toNotThrow() must be a function, %s was given', this.actual);\n\n      (0, _assert2.default)(!(0, _TestUtils.functionThrows)(this.actual, this.context, this.args, value), message || 'Expected %s to not throw %s', this.actual, value || 'an error');\n\n      return this;\n    }\n  }, {\n    key: 'toBeA',\n    value: function toBeA(value, message) {\n      (0, _assert2.default)((0, _TestUtils.isFunction)(value) || typeof value === 'string', 'The \"value\" argument in toBeA(value) must be a function or a string');\n\n      (0, _assert2.default)((0, _TestUtils.isA)(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toNotBeA',\n    value: function toNotBeA(value, message) {\n      (0, _assert2.default)((0, _TestUtils.isFunction)(value) || typeof value === 'string', 'The \"value\" argument in toNotBeA(value) must be a function or a string');\n\n      (0, _assert2.default)(!(0, _TestUtils.isA)(this.actual, value), message || 'Expected %s to not be a %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toMatch',\n    value: function toMatch(pattern, message) {\n      (0, _assert2.default)((0, _tmatch2.default)(this.actual, pattern), message || 'Expected %s to match %s', this.actual, pattern);\n\n      return this;\n    }\n  }, {\n    key: 'toNotMatch',\n    value: function toNotMatch(pattern, message) {\n      (0, _assert2.default)(!(0, _tmatch2.default)(this.actual, pattern), message || 'Expected %s to not match %s', this.actual, pattern);\n\n      return this;\n    }\n  }, {\n    key: 'toBeLessThan',\n    value: function toBeLessThan(value, message) {\n      (0, _assert2.default)(typeof this.actual === 'number', 'The \"actual\" argument in expect(actual).toBeLessThan() must be a number');\n\n      (0, _assert2.default)(typeof value === 'number', 'The \"value\" argument in toBeLessThan(value) must be a number');\n\n      (0, _assert2.default)(this.actual < value, message || 'Expected %s to be less than %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toBeLessThanOrEqualTo',\n    value: function toBeLessThanOrEqualTo(value, message) {\n      (0, _assert2.default)(typeof this.actual === 'number', 'The \"actual\" argument in expect(actual).toBeLessThanOrEqualTo() must be a number');\n\n      (0, _assert2.default)(typeof value === 'number', 'The \"value\" argument in toBeLessThanOrEqualTo(value) must be a number');\n\n      (0, _assert2.default)(this.actual <= value, message || 'Expected %s to be less than or equal to %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toBeGreaterThan',\n    value: function toBeGreaterThan(value, message) {\n      (0, _assert2.default)(typeof this.actual === 'number', 'The \"actual\" argument in expect(actual).toBeGreaterThan() must be a number');\n\n      (0, _assert2.default)(typeof value === 'number', 'The \"value\" argument in toBeGreaterThan(value) must be a number');\n\n      (0, _assert2.default)(this.actual > value, message || 'Expected %s to be greater than %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toBeGreaterThanOrEqualTo',\n    value: function toBeGreaterThanOrEqualTo(value, message) {\n      (0, _assert2.default)(typeof this.actual === 'number', 'The \"actual\" argument in expect(actual).toBeGreaterThanOrEqualTo() must be a number');\n\n      (0, _assert2.default)(typeof value === 'number', 'The \"value\" argument in toBeGreaterThanOrEqualTo(value) must be a number');\n\n      (0, _assert2.default)(this.actual >= value, message || 'Expected %s to be greater than or equal to %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toInclude',\n    value: function toInclude(value, compareValues, message) {\n      if (typeof compareValues === 'string') {\n        message = compareValues;\n        compareValues = null;\n      }\n\n      if (compareValues == null) compareValues = _TestUtils.isEqual;\n\n      var contains = false;\n\n      if ((0, _TestUtils.isArray)(this.actual)) {\n        contains = (0, _TestUtils.arrayContains)(this.actual, value, compareValues);\n      } else if ((0, _TestUtils.isObject)(this.actual)) {\n        contains = (0, _TestUtils.objectContains)(this.actual, value, compareValues);\n      } else if (typeof this.actual === 'string') {\n        contains = (0, _TestUtils.stringContains)(this.actual, value);\n      } else {\n        (0, _assert2.default)(false, 'The \"actual\" argument in expect(actual).toInclude() must be an array, object, or a string');\n      }\n\n      (0, _assert2.default)(contains, message || 'Expected %s to include %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toExclude',\n    value: function toExclude(value, compareValues, message) {\n      if (typeof compareValues === 'string') {\n        message = compareValues;\n        compareValues = null;\n      }\n\n      if (compareValues == null) compareValues = _TestUtils.isEqual;\n\n      var contains = false;\n\n      if ((0, _TestUtils.isArray)(this.actual)) {\n        contains = (0, _TestUtils.arrayContains)(this.actual, value, compareValues);\n      } else if ((0, _TestUtils.isObject)(this.actual)) {\n        contains = (0, _TestUtils.objectContains)(this.actual, value, compareValues);\n      } else if (typeof this.actual === 'string') {\n        contains = (0, _TestUtils.stringContains)(this.actual, value);\n      } else {\n        (0, _assert2.default)(false, 'The \"actual\" argument in expect(actual).toExclude() must be an array, object, or a string');\n      }\n\n      (0, _assert2.default)(!contains, message || 'Expected %s to exclude %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toIncludeKeys',\n    value: function toIncludeKeys(keys, comparator, message) {\n      var _this = this;\n\n      if (typeof comparator === 'string') {\n        message = comparator;\n        comparator = null;\n      }\n\n      if (comparator == null) comparator = _has2.default;\n\n      (0, _assert2.default)(_typeof(this.actual) === 'object', 'The \"actual\" argument in expect(actual).toIncludeKeys() must be an object, not %s', this.actual);\n\n      (0, _assert2.default)((0, _TestUtils.isArray)(keys), 'The \"keys\" argument in expect(actual).toIncludeKeys(keys) must be an array, not %s', keys);\n\n      var contains = keys.every(function (key) {\n        return comparator(_this.actual, key);\n      });\n\n      (0, _assert2.default)(contains, message || 'Expected %s to include key(s) %s', this.actual, keys.join(', '));\n\n      return this;\n    }\n  }, {\n    key: 'toIncludeKey',\n    value: function toIncludeKey(key) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return this.toIncludeKeys.apply(this, [[key]].concat(args));\n    }\n  }, {\n    key: 'toExcludeKeys',\n    value: function toExcludeKeys(keys, comparator, message) {\n      var _this2 = this;\n\n      if (typeof comparator === 'string') {\n        message = comparator;\n        comparator = null;\n      }\n\n      if (comparator == null) comparator = _has2.default;\n\n      (0, _assert2.default)(_typeof(this.actual) === 'object', 'The \"actual\" argument in expect(actual).toExcludeKeys() must be an object, not %s', this.actual);\n\n      (0, _assert2.default)((0, _TestUtils.isArray)(keys), 'The \"keys\" argument in expect(actual).toIncludeKeys(keys) must be an array, not %s', keys);\n\n      var contains = keys.every(function (key) {\n        return comparator(_this2.actual, key);\n      });\n\n      (0, _assert2.default)(!contains, message || 'Expected %s to exclude key(s) %s', this.actual, keys.join(', '));\n\n      return this;\n    }\n  }, {\n    key: 'toExcludeKey',\n    value: function toExcludeKey(key) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return this.toExcludeKeys.apply(this, [[key]].concat(args));\n    }\n  }, {\n    key: 'toHaveBeenCalled',\n    value: function toHaveBeenCalled(message) {\n      var spy = this.actual;\n\n      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The \"actual\" argument in expect(actual).toHaveBeenCalled() must be a spy');\n\n      (0, _assert2.default)(spy.calls.length > 0, message || 'spy was not called');\n\n      return this;\n    }\n  }, {\n    key: 'toHaveBeenCalledWith',\n    value: function toHaveBeenCalledWith() {\n      for (var _len3 = arguments.length, expectedArgs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        expectedArgs[_key3] = arguments[_key3];\n      }\n\n      var spy = this.actual;\n\n      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The \"actual\" argument in expect(actual).toHaveBeenCalledWith() must be a spy');\n\n      (0, _assert2.default)(spy.calls.some(function (call) {\n        return (0, _TestUtils.isEqual)(call.arguments, expectedArgs);\n      }), 'spy was never called with %s', expectedArgs);\n\n      return this;\n    }\n  }, {\n    key: 'toNotHaveBeenCalled',\n    value: function toNotHaveBeenCalled(message) {\n      var spy = this.actual;\n\n      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The \"actual\" argument in expect(actual).toNotHaveBeenCalled() must be a spy');\n\n      (0, _assert2.default)(spy.calls.length === 0, message || 'spy was not supposed to be called');\n\n      return this;\n    }\n  }]);\n\n  return Expectation;\n}();\n\nvar deprecate = function deprecate(fn, message) {\n  var alreadyWarned = false;\n\n  return function () {\n    if (!alreadyWarned) {\n      alreadyWarned = true;\n      console.warn(message);\n    }\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return fn.apply(this, args);\n  };\n};\n\nExpectation.prototype.withContext = deprecate(function (context) {\n  (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The \"actual\" argument in expect(actual).withContext() must be a function');\n\n  this.context = context;\n\n  return this;\n}, '\\nwithContext is deprecated; use a closure instead.\\n\\n  expect(fn).withContext(context).toThrow()\\n\\nbecomes\\n\\n  expect(() => fn.call(context)).toThrow()\\n');\n\nExpectation.prototype.withArgs = deprecate(function () {\n  var _args;\n\n  (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The \"actual\" argument in expect(actual).withArgs() must be a function');\n\n  if (arguments.length) this.args = (_args = this.args).concat.apply(_args, arguments);\n\n  return this;\n}, '\\nwithArgs is deprecated; use a closure instead.\\n\\n  expect(fn).withArgs(a, b, c).toThrow()\\n\\nbecomes\\n\\n  expect(() => fn(a, b, c)).toThrow()\\n');\n\nvar aliases = {\n  toBeAn: 'toBeA',\n  toNotBeAn: 'toNotBeA',\n  toBeTruthy: 'toExist',\n  toBeFalsy: 'toNotExist',\n  toBeFewerThan: 'toBeLessThan',\n  toBeMoreThan: 'toBeGreaterThan',\n  toContain: 'toInclude',\n  toNotContain: 'toExclude',\n  toNotInclude: 'toExclude',\n  toContainKeys: 'toIncludeKeys',\n  toNotContainKeys: 'toExcludeKeys',\n  toNotIncludeKeys: 'toExcludeKeys',\n  toContainKey: 'toIncludeKey',\n  toNotContainKey: 'toExcludeKey',\n  toNotIncludeKey: 'toExcludeKey'\n};\n\nfor (var alias in aliases) {\n  if (aliases.hasOwnProperty(alias)) Expectation.prototype[alias] = Expectation.prototype[aliases[alias]];\n}exports.default = Expectation;",
    "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.spyOn = exports.createSpy = exports.restoreSpies = exports.isSpy = undefined;\n\nvar _defineProperties = require('define-properties');\n\nvar _assert = require('./assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _TestUtils = require('./TestUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*eslint-disable prefer-rest-params, no-underscore-dangle*/\n\n\nvar noop = function noop() {};\n\nvar supportsConfigurableFnLength = _defineProperties.supportsDescriptors && Object.getOwnPropertyDescriptor(function () {}, 'length').configurable;\n\nvar isSpy = exports.isSpy = function isSpy(object) {\n  return object && object.__isSpy === true;\n};\n\nvar spies = [];\n\nvar restoreSpies = exports.restoreSpies = function restoreSpies() {\n  for (var i = spies.length - 1; i >= 0; i--) {\n    spies[i].restore();\n  }spies = [];\n};\n\nvar createSpy = exports.createSpy = function createSpy(fn) {\n  var restore = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];\n\n  if (fn == null) fn = noop;\n\n  (0, _assert2.default)((0, _TestUtils.isFunction)(fn), 'createSpy needs a function');\n\n  var targetFn = void 0,\n      thrownValue = void 0,\n      returnValue = void 0,\n      spy = void 0;\n\n  function spyLogic() {\n    spy.calls.push({\n      context: this,\n      arguments: Array.prototype.slice.call(arguments, 0)\n    });\n\n    if (targetFn) return targetFn.apply(this, arguments);\n\n    if (thrownValue) throw thrownValue;\n\n    return returnValue;\n  }\n\n  if (supportsConfigurableFnLength) {\n    spy = Object.defineProperty(spyLogic, 'length', { value: fn.length, writable: false, enumerable: false, configurable: true });\n  } else {\n    spy = new Function('spy', 'return function(' + // eslint-disable-line no-new-func\n    [].concat(_toConsumableArray(Array(fn.length))).map(function (_, i) {\n      return '_' + i;\n    }).join(',') + ') {\\n      return spy.apply(this, arguments)\\n    }')(spyLogic);\n  }\n\n  spy.calls = [];\n\n  spy.andCall = function (otherFn) {\n    targetFn = otherFn;\n    return spy;\n  };\n\n  spy.andCallThrough = function () {\n    return spy.andCall(fn);\n  };\n\n  spy.andThrow = function (value) {\n    thrownValue = value;\n    return spy;\n  };\n\n  spy.andReturn = function (value) {\n    returnValue = value;\n    return spy;\n  };\n\n  spy.getLastCall = function () {\n    return spy.calls[spy.calls.length - 1];\n  };\n\n  spy.reset = function () {\n    spy.calls = [];\n  };\n\n  spy.restore = spy.destroy = restore;\n\n  spy.__isSpy = true;\n\n  spies.push(spy);\n\n  return spy;\n};\n\nvar spyOn = exports.spyOn = function spyOn(object, methodName) {\n  var original = object[methodName];\n\n  if (!isSpy(original)) {\n    (0, _assert2.default)((0, _TestUtils.isFunction)(original), 'Cannot spyOn the %s property; it is not a function', methodName);\n\n    object[methodName] = createSpy(original, function () {\n      object[methodName] = original;\n    });\n  }\n\n  return object[methodName];\n};",
    "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringContains = exports.objectContains = exports.arrayContains = exports.functionThrows = exports.isA = exports.isObject = exports.isArray = exports.isFunction = exports.isEqual = exports.whyNotEqual = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _isRegex = require('is-regex');\n\nvar _isRegex2 = _interopRequireDefault(_isRegex);\n\nvar _why = require('is-equal/why');\n\nvar _why2 = _interopRequireDefault(_why);\n\nvar _objectKeys = require('object-keys');\n\nvar _objectKeys2 = _interopRequireDefault(_objectKeys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Returns the reason why the given arguments are not *conceptually*\n * equal, if any; the empty string otherwise.\n */\nvar whyNotEqual = exports.whyNotEqual = function whyNotEqual(a, b) {\n  return a == b ? '' : (0, _why2.default)(a, b);\n};\n\n/**\n * Returns true if the given arguments are *conceptually* equal.\n */\nvar isEqual = exports.isEqual = function isEqual(a, b) {\n  return whyNotEqual(a, b) === '';\n};\n\n/**\n * Returns true if the given object is a function.\n */\nvar isFunction = exports.isFunction = function isFunction(object) {\n  return typeof object === 'function';\n};\n\n/**\n * Returns true if the given object is an array.\n */\nvar isArray = exports.isArray = function isArray(object) {\n  return Array.isArray(object);\n};\n\n/**\n * Returns true if the given object is an object.\n */\nvar isObject = exports.isObject = function isObject(object) {\n  return object && !isArray(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';\n};\n\n/**\n * Returns true if the given object is an instanceof value\n * or its typeof is the given value.\n */\nvar isA = exports.isA = function isA(object, value) {\n  if (isFunction(value)) return object instanceof value;\n\n  if (value === 'array') return Array.isArray(object);\n\n  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === value;\n};\n\n/**\n * Returns true if the given function throws the given value\n * when invoked. The value may be:\n *\n * - undefined, to merely assert there was a throw\n * - a constructor function, for comparing using instanceof\n * - a regular expression, to compare with the error message\n * - a string, to find in the error message\n */\nvar functionThrows = exports.functionThrows = function functionThrows(fn, context, args, value) {\n  try {\n    fn.apply(context, args);\n  } catch (error) {\n    if (value == null) return true;\n\n    if (isFunction(value) && error instanceof value) return true;\n\n    var message = error.message || error;\n\n    if (typeof message === 'string') {\n      if ((0, _isRegex2.default)(value) && value.test(error.message)) return true;\n\n      if (typeof value === 'string' && message.indexOf(value) !== -1) return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Returns true if the given array contains the value, false\n * otherwise. The compareValues function must return false to\n * indicate a non-match.\n */\nvar arrayContains = exports.arrayContains = function arrayContains(array, value, compareValues) {\n  return array.some(function (item) {\n    return compareValues(item, value) !== false;\n  });\n};\n\nvar ownEnumerableKeys = function ownEnumerableKeys(object) {\n  if ((typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' && typeof Reflect.ownKeys === 'function') {\n    return Reflect.ownKeys(object).filter(function (key) {\n      return Object.getOwnPropertyDescriptor(object, key).enumerable;\n    });\n  }\n\n  if (typeof Object.getOwnPropertySymbols === 'function') {\n    return Object.getOwnPropertySymbols(object).filter(function (key) {\n      return Object.getOwnPropertyDescriptor(object, key).enumerable;\n    }).concat((0, _objectKeys2.default)(object));\n  }\n\n  return (0, _objectKeys2.default)(object);\n};\n\n/**\n * Returns true if the given object contains the value, false\n * otherwise. The compareValues function must return false to\n * indicate a non-match.\n */\nvar objectContains = exports.objectContains = function objectContains(object, value, compareValues) {\n  return ownEnumerableKeys(value).every(function (k) {\n    if (isObject(object[k]) && isObject(value[k])) return objectContains(object[k], value[k], compareValues);\n\n    return compareValues(object[k], value[k]);\n  });\n};\n\n/**\n * Returns true if the given string contains the value, false otherwise.\n */\nvar stringContains = exports.stringContains = function stringContains(string, value) {\n  return string.indexOf(value) !== -1;\n};",
    "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _objectInspect = require('object-inspect');\n\nvar _objectInspect2 = _interopRequireDefault(_objectInspect);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar formatString = function formatString(string, args) {\n  var index = 0;\n  return string.replace(/%s/g, function () {\n    return (0, _objectInspect2.default)(args[index++]);\n  });\n};\n\nvar assert = function assert(condition, createMessage) {\n  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    extraArgs[_key - 2] = arguments[_key];\n  }\n\n  if (condition) return;\n\n  var message = typeof createMessage === 'string' ? formatString(createMessage, extraArgs) : createMessage(extraArgs);\n\n  throw new Error(message);\n};\n\nexports.default = assert;",
    "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Expectation = require('./Expectation');\n\nvar _Expectation2 = _interopRequireDefault(_Expectation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Extensions = [];\n\nfunction extend(extension) {\n  if (Extensions.indexOf(extension) === -1) {\n    Extensions.push(extension);\n\n    for (var p in extension) {\n      if (extension.hasOwnProperty(p)) _Expectation2.default.prototype[p] = extension[p];\n    }\n  }\n}\n\nexports.default = extend;",
    "'use strict';\n\nvar _Expectation = require('./Expectation');\n\nvar _Expectation2 = _interopRequireDefault(_Expectation);\n\nvar _SpyUtils = require('./SpyUtils');\n\nvar _assert = require('./assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _extend = require('./extend');\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction expect(actual) {\n  return new _Expectation2.default(actual);\n}\n\nexpect.createSpy = _SpyUtils.createSpy;\nexpect.spyOn = _SpyUtils.spyOn;\nexpect.isSpy = _SpyUtils.isSpy;\nexpect.restoreSpies = _SpyUtils.restoreSpies;\nexpect.assert = _assert2.default;\nexpect.extend = _extend2.default;\n\nmodule.exports = expect;",
    "'use strict';\n\nvar keys = require('object-keys');\nvar foreach = require('foreach');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';\n\nvar toStr = Object.prototype.toString;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\tObject.defineProperty(obj, 'x', { enumerable: false, value: obj });\n        /* eslint-disable no-unused-vars, no-restricted-syntax */\n        for (var _ in obj) { return false; }\n        /* eslint-enable no-unused-vars, no-restricted-syntax */\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\tObject.defineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = props.concat(Object.getOwnPropertySymbols(map));\n\t}\n\tforeach(props, function (name) {\n\t\tdefineProperty(object, name, map[name], predicates[name]);\n\t});\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n",
    "\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n",
    "var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n",
    "var implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n",
    "var bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n",
    "'use strict';\n\nmodule.exports = function () {\n\tvar mapForEach = (function () {\n\t\tif (typeof Map !== 'function') { return null; }\n\t\ttry {\n\t\t\tMap.prototype.forEach.call({}, function () {});\n\t\t} catch (e) {\n\t\t\treturn Map.prototype.forEach;\n\t\t}\n\t\treturn null;\n\t}());\n\n\tvar setForEach = (function () {\n\t\tif (typeof Set !== 'function') { return null; }\n\t\ttry {\n\t\t\tSet.prototype.forEach.call({}, function () {});\n\t\t} catch (e) {\n\t\t\treturn Set.prototype.forEach;\n\t\t}\n\t\treturn null;\n\t}());\n\n\treturn { Map: mapForEach, Set: setForEach };\n};\n",
    "'use strict';\n\nvar isSymbol = require('is-symbol');\n\nmodule.exports = function getSymbolIterator() {\n\tvar symbolIterator = typeof Symbol === 'function' && isSymbol(Symbol.iterator) ? Symbol.iterator : null;\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && typeof Map === 'function' && typeof Map.prototype.entries === 'function') {\n\t\tObject.getOwnPropertyNames(Map.prototype).forEach(function (name) {\n\t\t\tif (name !== 'entries' && name !== 'size' && Map.prototype[name] === Map.prototype.entries) {\n\t\t\t\tsymbolIterator = name;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn symbolIterator;\n};\n",
    "'use strict';\n\nvar isCallable = require('is-callable');\nvar fnToStr = Function.prototype.toString;\nvar isNonArrowFnRegex = /^\\s*function/;\nvar isArrowFnWithParensRegex = /^\\([^\\)]*\\) *=>/;\nvar isArrowFnWithoutParensRegex = /^[^=]*=>/;\n\nmodule.exports = function isArrowFunction(fn) {\n\tif (!isCallable(fn)) { return false; }\n\tvar fnStr = fnToStr.call(fn);\n\treturn fnStr.length > 0 &&\n\t\t!isNonArrowFnRegex.test(fnStr) &&\n\t\t(isArrowFnWithParensRegex.test(fnStr) || isArrowFnWithoutParensRegex.test(fnStr));\n};\n",
    "'use strict';\n\nvar boolToStr = Boolean.prototype.toString;\n\nvar tryBooleanObject = function tryBooleanObject(value) {\n\ttry {\n\t\tboolToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar boolClass = '[object Boolean]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isBoolean(value) {\n\tif (typeof value === 'boolean') { return true; }\n\tif (typeof value !== 'object') { return false; }\n\treturn hasToStringTag ? tryBooleanObject(value) : toStr.call(value) === boolClass;\n};\n",
    "'use strict';\n\nvar fnToStr = Function.prototype.toString;\n\nvar constructorRegex = /^\\s*class /;\nvar isES6ClassFn = function isES6ClassFn(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\tvar singleStripped = fnStr.replace(/\\/\\/.*\\n/g, '');\n\t\tvar multiStripped = singleStripped.replace(/\\/\\*[.\\s\\S]*\\*\\//g, '');\n\t\tvar spaceStripped = multiStripped.replace(/\\n/mg, ' ').replace(/ {2}/g, ' ');\n\t\treturn constructorRegex.test(spaceStripped);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionObject(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isCallable(value) {\n\tif (!value) { return false; }\n\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\tif (hasToStringTag) { return tryFunctionObject(value); }\n\tif (isES6ClassFn(value)) { return false; }\n\tvar strClass = toStr.call(value);\n\treturn strClass === fnClass || strClass === genClass;\n};\n",
    "'use strict';\n\nvar getDay = Date.prototype.getDay;\nvar tryDateObject = function tryDateObject(value) {\n\ttry {\n\t\tgetDay.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar toStr = Object.prototype.toString;\nvar dateClass = '[object Date]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isDateObject(value) {\n\tif (typeof value !== 'object' || value === null) { return false; }\n\treturn hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;\n};\n",
    "'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*function\\*/;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') { return false; }\n\tvar fnStr = toStr.call(fn);\n\treturn (fnStr === '[object Function]' || fnStr === '[object GeneratorFunction]') && isFnRegex.test(fnToStr.call(fn));\n};\n\n",
    "'use strict';\n\nvar numToStr = Number.prototype.toString;\nvar tryNumberObject = function tryNumberObject(value) {\n\ttry {\n\t\tnumToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar numClass = '[object Number]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isNumberObject(value) {\n\tif (typeof value === 'number') { return true; }\n\tif (typeof value !== 'object') { return false; }\n\treturn hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;\n};\n",
    "'use strict';\n\nvar strValue = String.prototype.valueOf;\nvar tryStringObject = function tryStringObject(value) {\n\ttry {\n\t\tstrValue.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar strClass = '[object String]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isString(value) {\n\tif (typeof value === 'string') { return true; }\n\tif (typeof value !== 'object') { return false; }\n\treturn hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;\n};\n",
    "'use strict';\n\nvar toStr = Object.prototype.toString;\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';\n\nif (hasSymbols) {\n\tvar symToStr = Symbol.prototype.toString;\n\tvar symStringRegex = /^Symbol\\(.*\\)$/;\n\tvar isSymbolObject = function isSymbolObject(value) {\n\t\tif (typeof value.valueOf() !== 'symbol') { return false; }\n\t\treturn symStringRegex.test(symToStr.call(value));\n\t};\n\tmodule.exports = function isSymbol(value) {\n\t\tif (typeof value === 'symbol') { return true; }\n\t\tif (toStr.call(value) !== '[object Symbol]') { return false; }\n\t\ttry {\n\t\t\treturn isSymbolObject(value);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n} else {\n\tmodule.exports = function isSymbol(value) {\n\t\t// this environment does not support Symbols.\n\t\treturn false;\n\t};\n}\n",
    "'use strict';\n\nvar ObjectPrototype = Object.prototype;\nvar toStr = ObjectPrototype.toString;\nvar booleanValue = Boolean.prototype.valueOf;\nvar has = require('has');\nvar isArrowFunction = require('is-arrow-function');\nvar isBoolean = require('is-boolean-object');\nvar isDate = require('is-date-object');\nvar isGenerator = require('is-generator-function');\nvar isNumber = require('is-number-object');\nvar isRegex = require('is-regex');\nvar isString = require('is-string');\nvar isSymbol = require('is-symbol');\nvar isCallable = require('is-callable');\n\nvar isProto = Object.prototype.isPrototypeOf;\n\nvar foo = function foo() {};\nvar functionsHaveNames = foo.name === 'foo';\n\nvar symbolValue = typeof Symbol === 'function' ? Symbol.prototype.valueOf : null;\nvar symbolIterator = require('./getSymbolIterator')();\n\nvar collectionsForEach = require('./getCollectionsForEach')();\n\nvar getPrototypeOf = Object.getPrototypeOf;\nif (!getPrototypeOf) {\n\t/* eslint-disable no-proto */\n\tif (typeof 'test'.__proto__ === 'object') {\n\t\tgetPrototypeOf = function (obj) {\n\t\t\treturn obj.__proto__;\n\t\t};\n\t} else {\n\t\tgetPrototypeOf = function (obj) {\n\t\t\tvar constructor = obj.constructor,\n\t\t\t\toldConstructor;\n\t\t\tif (has(obj, 'constructor')) {\n\t\t\t\toldConstructor = constructor;\n\t\t\t\tif (!(delete obj.constructor)) { // reset constructor\n\t\t\t\t\treturn null; // can't delete obj.constructor, return null\n\t\t\t\t}\n\t\t\t\tconstructor = obj.constructor; // get real constructor\n\t\t\t\tobj.constructor = oldConstructor; // restore constructor\n\t\t\t}\n\t\t\treturn constructor ? constructor.prototype : ObjectPrototype; // needed for IE\n\t\t};\n\t}\n\t/* eslint-enable no-proto */\n}\n\nvar isArray = Array.isArray || function (value) {\n\treturn toStr.call(value) === '[object Array]';\n};\n\nvar normalizeFnWhitespace = function normalizeFnWhitespace(fnStr) {\n\t// this is needed in IE 9, at least, which has inconsistencies here.\n\treturn fnStr.replace(/^function ?\\(/, 'function (').replace('){', ') {');\n};\n\nvar tryMapSetEntries = function tryMapSetEntries(collection) {\n\tvar foundEntries = [];\n\ttry {\n\t\tcollectionsForEach.Map.call(collection, function (key, value) {\n\t\t\tfoundEntries.push([key, value]);\n\t\t});\n\t} catch (notMap) {\n\t\ttry {\n\t\t\tcollectionsForEach.Set.call(collection, function (value) {\n\t\t\t\tfoundEntries.push([value]);\n\t\t\t});\n\t\t} catch (notSet) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn foundEntries;\n};\n\nmodule.exports = function whyNotEqual(value, other) {\n\tif (value === other) { return ''; }\n\tif (value == null || other == null) {\n\t\treturn value === other ? '' : String(value) + ' !== ' + String(other);\n\t}\n\n\tvar valToStr = toStr.call(value);\n\tvar otherToStr = toStr.call(other);\n\tif (valToStr !== otherToStr) {\n\t\treturn 'toStringTag is not the same: ' + valToStr + ' !== ' + otherToStr;\n\t}\n\n\tvar valIsBool = isBoolean(value);\n\tvar otherIsBool = isBoolean(other);\n\tif (valIsBool || otherIsBool) {\n\t\tif (!valIsBool) { return 'first argument is not a boolean; second argument is'; }\n\t\tif (!otherIsBool) { return 'second argument is not a boolean; first argument is'; }\n\t\tvar valBoolVal = booleanValue.call(value);\n\t\tvar otherBoolVal = booleanValue.call(other);\n\t\tif (valBoolVal === otherBoolVal) { return ''; }\n\t\treturn 'primitive value of boolean arguments do not match: ' + valBoolVal + ' !== ' + otherBoolVal;\n\t}\n\n\tvar valIsNumber = isNumber(value);\n\tvar otherIsNumber = isNumber(value);\n\tif (valIsNumber || otherIsNumber) {\n\t\tif (!valIsNumber) { return 'first argument is not a number; second argument is'; }\n\t\tif (!otherIsNumber) { return 'second argument is not a number; first argument is'; }\n\t\tvar valNum = Number(value);\n\t\tvar otherNum = Number(other);\n\t\tif (valNum === otherNum) { return ''; }\n\t\tvar valIsNaN = isNaN(value);\n\t\tvar otherIsNaN = isNaN(other);\n\t\tif (valIsNaN && !otherIsNaN) {\n\t\t\treturn 'first argument is NaN; second is not';\n\t\t} else if (!valIsNaN && otherIsNaN) {\n\t\t\treturn 'second argument is NaN; first is not';\n\t\t} else if (valIsNaN && otherIsNaN) {\n\t\t\treturn '';\n\t\t}\n\t\treturn 'numbers are different: ' + value + ' !== ' + other;\n\t}\n\n\tvar valIsString = isString(value);\n\tvar otherIsString = isString(other);\n\tif (valIsString || otherIsString) {\n\t\tif (!valIsString) { return 'second argument is string; first is not'; }\n\t\tif (!otherIsString) { return 'first argument is string; second is not'; }\n\t\tvar stringVal = String(value);\n\t\tvar otherVal = String(other);\n\t\tif (stringVal === otherVal) { return ''; }\n\t\treturn 'string values are different: \"' + stringVal + '\" !== \"' + otherVal + '\"';\n\t}\n\n\tvar valIsDate = isDate(value);\n\tvar otherIsDate = isDate(other);\n\tif (valIsDate || otherIsDate) {\n\t\tif (!valIsDate) { return 'second argument is Date, first is not'; }\n\t\tif (!otherIsDate) { return 'first argument is Date, second is not'; }\n\t\tvar valTime = +value;\n\t\tvar otherTime = +other;\n\t\tif (valTime === otherTime) { return ''; }\n\t\treturn 'Dates have different time values: ' + valTime + ' !== ' + otherTime;\n\t}\n\n\tvar valIsRegex = isRegex(value);\n\tvar otherIsRegex = isRegex(other);\n\tif (valIsRegex || otherIsRegex) {\n\t\tif (!valIsRegex) { return 'second argument is RegExp, first is not'; }\n\t\tif (!otherIsRegex) { return 'first argument is RegExp, second is not'; }\n\t\tvar regexStringVal = String(value);\n\t\tvar regexStringOther = String(other);\n\t\tif (regexStringVal === regexStringOther) { return ''; }\n\t\treturn 'regular expressions differ: ' + regexStringVal + ' !== ' + regexStringOther;\n\t}\n\n\tvar valIsArray = isArray(value);\n\tvar otherIsArray = isArray(other);\n\tif (valIsArray || otherIsArray) {\n\t\tif (!valIsArray) { return 'second argument is an Array, first is not'; }\n\t\tif (!otherIsArray) { return 'first argument is an Array, second is not'; }\n\t\tif (value.length !== other.length) {\n\t\t\treturn 'arrays have different length: ' + value.length + ' !== ' + other.length;\n\t\t}\n\t\tif (String(value) !== String(other)) { return 'stringified Arrays differ'; }\n\n\t\tvar index = value.length - 1;\n\t\tvar equal = '';\n\t\tvar valHasIndex, otherHasIndex;\n\t\twhile (equal === '' && index >= 0) {\n\t\t\tvalHasIndex = has(value, index);\n\t\t\totherHasIndex = has(other, index);\n\t\t\tif (!valHasIndex && otherHasIndex) { return 'second argument has index ' + index + '; first does not'; }\n\t\t\tif (valHasIndex && !otherHasIndex) { return 'first argument has index ' + index + '; second does not'; }\n\t\t\tequal = whyNotEqual(value[index], other[index]);\n\t\t\tindex -= 1;\n\t\t}\n\t\treturn equal;\n\t}\n\n\tvar valueIsSym = isSymbol(value);\n\tvar otherIsSym = isSymbol(other);\n\tif (valueIsSym !== otherIsSym) {\n\t\tif (valueIsSym) { return 'first argument is Symbol; second is not'; }\n\t\treturn 'second argument is Symbol; first is not';\n\t}\n\tif (valueIsSym && otherIsSym) {\n\t\treturn symbolValue.call(value) === symbolValue.call(other) ? '' : 'first Symbol value !== second Symbol value';\n\t}\n\n\tvar valueIsGen = isGenerator(value);\n\tvar otherIsGen = isGenerator(other);\n\tif (valueIsGen !== otherIsGen) {\n\t\tif (valueIsGen) { return 'first argument is a Generator; second is not'; }\n\t\treturn 'second argument is a Generator; first is not';\n\t}\n\n\tvar valueIsArrow = isArrowFunction(value);\n\tvar otherIsArrow = isArrowFunction(other);\n\tif (valueIsArrow !== otherIsArrow) {\n\t\tif (valueIsArrow) { return 'first argument is an Arrow function; second is not'; }\n\t\treturn 'second argument is an Arrow function; first is not';\n\t}\n\n\tif (isCallable(value) || isCallable(other)) {\n\t\tif (functionsHaveNames && whyNotEqual(value.name, other.name) !== '') {\n\t\t\treturn 'Function names differ: \"' + value.name + '\" !== \"' + other.name + '\"';\n\t\t}\n\t\tif (whyNotEqual(value.length, other.length) !== '') {\n\t\t\treturn 'Function lengths differ: ' + value.length + ' !== ' + other.length;\n\t\t}\n\n\t\tvar valueStr = normalizeFnWhitespace(String(value));\n\t\tvar otherStr = normalizeFnWhitespace(String(other));\n\t\tif (whyNotEqual(valueStr, otherStr) === '') { return ''; }\n\n\t\tif (!valueIsGen && !valueIsArrow) {\n\t\t\treturn whyNotEqual(valueStr.replace(/\\)\\s*\\{/, '){'), otherStr.replace(/\\)\\s*\\{/, '){')) === '' ? '' : 'Function string representations differ';\n\t\t}\n\t\treturn whyNotEqual(valueStr, otherStr) === '' ? '' : 'Function string representations differ';\n\t}\n\n\tif (typeof value === 'object' || typeof other === 'object') {\n\t\tif (typeof value !== typeof other) { return 'arguments have a different typeof: ' + typeof value + ' !== ' + typeof other; }\n\t\tif (isProto.call(value, other)) { return 'first argument is the [[Prototype]] of the second'; }\n\t\tif (isProto.call(other, value)) { return 'second argument is the [[Prototype]] of the first'; }\n\t\tif (getPrototypeOf(value) !== getPrototypeOf(other)) { return 'arguments have a different [[Prototype]]'; }\n\n\t\tif (symbolIterator) {\n\t\t\tvar valueIteratorFn = value[symbolIterator];\n\t\t\tvar valueIsIterable = isCallable(valueIteratorFn);\n\t\t\tvar otherIteratorFn = other[symbolIterator];\n\t\t\tvar otherIsIterable = isCallable(otherIteratorFn);\n\t\t\tif (valueIsIterable !== otherIsIterable) {\n\t\t\t\tif (valueIsIterable) { return 'first argument is iterable; second is not'; }\n\t\t\t\treturn 'second argument is iterable; first is not';\n\t\t\t}\n\t\t\tif (valueIsIterable && otherIsIterable) {\n\t\t\t\tvar valueIterator = valueIteratorFn.call(value);\n\t\t\t\tvar otherIterator = otherIteratorFn.call(other);\n\t\t\t\tvar valueNext, otherNext, nextWhy;\n\t\t\t\tdo {\n\t\t\t\t\tvalueNext = valueIterator.next();\n\t\t\t\t\totherNext = otherIterator.next();\n\t\t\t\t\tif (!valueNext.done && !otherNext.done) {\n\t\t\t\t\t\tnextWhy = whyNotEqual(valueNext, otherNext);\n\t\t\t\t\t\tif (nextWhy !== '') {\n\t\t\t\t\t\t\treturn 'iteration results are not equal: ' + nextWhy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (!valueNext.done && !otherNext.done);\n\t\t\t\tif (valueNext.done && !otherNext.done) { return 'first argument finished iterating before second'; }\n\t\t\t\tif (!valueNext.done && otherNext.done) { return 'second argument finished iterating before first'; }\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (collectionsForEach.Map || collectionsForEach.Set) {\n\t\t\tvar valueEntries = tryMapSetEntries(value);\n\t\t\tvar otherEntries = tryMapSetEntries(other);\n\t\t\tvar valueEntriesIsArray = isArray(valueEntries);\n\t\t\tvar otherEntriesIsArray = isArray(otherEntries);\n\t\t\tif (valueEntriesIsArray && !otherEntriesIsArray) { return 'first argument has Collection entries, second does not'; }\n\t\t\tif (!valueEntriesIsArray && otherEntriesIsArray) { return 'second argument has Collection entries, first does not'; }\n\t\t\tif (valueEntriesIsArray && otherEntriesIsArray) {\n\t\t\t\tvar entriesWhy = whyNotEqual(valueEntries, otherEntries);\n\t\t\t\treturn entriesWhy === '' ? '' : 'Collection entries differ: ' + entriesWhy;\n\t\t\t}\n\t\t}\n\n\t\tvar key, valueKeyIsRecursive, otherKeyIsRecursive, keyWhy;\n\t\tfor (key in value) {\n\t\t\tif (has(value, key)) {\n\t\t\t\tif (!has(other, key)) { return 'first argument has key \"' + key + '\"; second does not'; }\n\t\t\t\tvalueKeyIsRecursive = !!value[key] && value[key][key] === value;\n\t\t\t\totherKeyIsRecursive = !!other[key] && other[key][key] === other;\n\t\t\t\tif (valueKeyIsRecursive !== otherKeyIsRecursive) {\n\t\t\t\t\tif (valueKeyIsRecursive) { return 'first argument has a circular reference at key \"' + key + '\"; second does not'; }\n\t\t\t\t\treturn 'second argument has a circular reference at key \"' + key + '\"; first does not';\n\t\t\t\t}\n\t\t\t\tif (!valueKeyIsRecursive && !otherKeyIsRecursive) {\n\t\t\t\t\tkeyWhy = whyNotEqual(value[key], other[key]);\n\t\t\t\t\tif (keyWhy !== '') {\n\t\t\t\t\t\treturn 'value at key \"' + key + '\" differs: ' + keyWhy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (key in other) {\n\t\t\tif (has(other, key) && !has(value, key)) {\n\t\t\t\treturn 'second argument has key \"' + key + '\"; first does not';\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\n\treturn false;\n};\n",
    "'use strict';\n\nvar regexExec = RegExp.prototype.exec;\nvar tryRegexExec = function tryRegexExec(value) {\n\ttry {\n\t\tregexExec.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar regexClass = '[object RegExp]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isRegex(value) {\n\tif (typeof value !== 'object') { return false; }\n\treturn hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;\n};\n",
    "var hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar booleanValueOf = Boolean.prototype.valueOf;\n\nmodule.exports = function inspect_ (obj, opts, depth, seen) {\n    if (!opts) opts = {};\n    \n    var maxDepth = opts.depth === undefined ? 5 : opts.depth;\n    if (depth === undefined) depth = 0;\n    if (depth >= maxDepth && maxDepth > 0 && obj && typeof obj === 'object') {\n        return '[Object]';\n    }\n    \n    if (seen === undefined) seen = [];\n    else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n    \n    function inspect (value, from) {\n        if (from) {\n            seen = seen.slice();\n            seen.push(from);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n    \n    if (typeof obj === 'string') {\n        return inspectString(obj);\n    }\n    else if (typeof obj === 'function') {\n        var name = nameOf(obj);\n        return '[Function' + (name ? ': ' + name : '') + ']';\n    }\n    else if (obj === null) {\n        return 'null';\n    }\n    else if (isSymbol(obj)) {\n        var symString = Symbol.prototype.toString.call(obj);\n        return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;\n    }\n    else if (isElement(obj)) {\n        var s = '<' + String(obj.nodeName).toLowerCase();\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=\"' + quote(attrs[i].value) + '\"';\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) s += '...';\n        s += '</' + String(obj.nodeName).toLowerCase() + '>';\n        return s;\n    }\n    else if (isArray(obj)) {\n        if (obj.length === 0) return '[]';\n        var xs = Array(obj.length);\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n        return '[ ' + xs.join(', ') + ' ]';\n    }\n    else if (isError(obj)) {\n        var parts = [];\n        for (var key in obj) {\n            if (!has(obj, key)) continue;\n            \n            if (/[^\\w$]/.test(key)) {\n                parts.push(inspect(key) + ': ' + inspect(obj[key]));\n            }\n            else {\n                parts.push(key + ': ' + inspect(obj[key]));\n            }\n        }\n        if (parts.length === 0) return '[' + obj + ']';\n        return '{ [' + obj + '] ' + parts.join(', ') + ' }';\n    }\n    else if (typeof obj === 'object' && typeof obj.inspect === 'function') {\n        return obj.inspect();\n    }\n    else if (isMap(obj)) {\n        var parts = [];\n        mapForEach.call(obj, function (value, key) {\n            parts.push(inspect(key, obj) + ' => ' + inspect(value, obj));\n        });\n        return 'Map (' + mapSize.call(obj) + ') {' + parts.join(', ') + '}';\n    }\n    else if (isSet(obj)) {\n        var parts = [];\n        setForEach.call(obj, function (value ) {\n            parts.push(inspect(value, obj));\n        });\n        return 'Set (' + setSize.call(obj) + ') {' + parts.join(', ') + '}';\n    }\n    else if (typeof obj !== 'object') {\n        return String(obj);\n    }\n    else if (isNumber(obj)) {\n        return 'Object(' + Number(obj) + ')';\n    }\n    else if (isBoolean(obj)) {\n        return 'Object(' + booleanValueOf.call(obj) + ')';\n    }\n    else if (isString(obj)) {\n        return 'Object(' + inspect(String(obj)) + ')';\n    }\n    else if (!isDate(obj) && !isRegExp(obj)) {\n        var xs = [], keys = [];\n        for (var key in obj) {\n            if (has(obj, key)) keys.push(key);\n        }\n        keys.sort();\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (/[^\\w$]/.test(key)) {\n                xs.push(inspect(key) + ': ' + inspect(obj[key], obj));\n            }\n            else xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n        if (xs.length === 0) return '{}';\n        return '{ ' + xs.join(', ') + ' }';\n    }\n    else return String(obj);\n};\n\nfunction quote (s) {\n    return String(s).replace(/\"/g, '&quot;');\n}\n\nfunction isArray (obj) { return toStr(obj) === '[object Array]' }\nfunction isDate (obj) { return toStr(obj) === '[object Date]' }\nfunction isRegExp (obj) { return toStr(obj) === '[object RegExp]' }\nfunction isError (obj) { return toStr(obj) === '[object Error]' }\nfunction isSymbol (obj) { return toStr(obj) === '[object Symbol]' }\nfunction isString (obj) { return toStr(obj) === '[object String]' }\nfunction isNumber (obj) { return toStr(obj) === '[object Number]' }\nfunction isBoolean (obj) { return toStr(obj) === '[object Boolean]' }\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has (obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr (obj) {\n    return Object.prototype.toString.call(obj);\n}\n\nfunction nameOf (f) {\n    if (f.name) return f.name;\n    var m = f.toString().match(/^function\\s*([\\w$]+)/);\n    if (m) return m[1];\n}\n\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) return i;\n    }\n    return -1;\n}\n\nfunction isMap (x) {\n    if (!mapSize) {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet (x) {\n    if (!setSize) {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement (x) {\n    if (!x || typeof x !== 'object') return false;\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string'\n        && typeof x.getAttribute === 'function'\n    ;\n}\n\nfunction inspectString (str) {\n    var s = str.replace(/(['\\\\])/g, '\\\\$1').replace(/[\\x00-\\x1f]/g, lowbyte);\n    return \"'\" + s + \"'\";\n    \n    function lowbyte (c) {\n        var n = c.charCodeAt(0);\n        var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];\n        if (x) return '\\\\' + x;\n        return '\\\\x' + (n < 0x10 ? '0' : '') + n.toString(16);\n    }\n}\n",
    "'use strict';\n\n// modified from https://github.com/es-shims/es5-shim\nvar has = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar slice = Array.prototype.slice;\nvar isArgs = require('./isArguments');\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\nvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\nvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\nvar dontEnums = [\n\t'toString',\n\t'toLocaleString',\n\t'valueOf',\n\t'hasOwnProperty',\n\t'isPrototypeOf',\n\t'propertyIsEnumerable',\n\t'constructor'\n];\nvar equalsConstructorPrototype = function (o) {\n\tvar ctor = o.constructor;\n\treturn ctor && ctor.prototype === o;\n};\nvar excludedKeys = {\n\t$console: true,\n\t$external: true,\n\t$frame: true,\n\t$frameElement: true,\n\t$frames: true,\n\t$innerHeight: true,\n\t$innerWidth: true,\n\t$outerHeight: true,\n\t$outerWidth: true,\n\t$pageXOffset: true,\n\t$pageYOffset: true,\n\t$parent: true,\n\t$scrollLeft: true,\n\t$scrollTop: true,\n\t$scrollX: true,\n\t$scrollY: true,\n\t$self: true,\n\t$webkitIndexedDB: true,\n\t$webkitStorageInfo: true,\n\t$window: true\n};\nvar hasAutomationEqualityBug = (function () {\n\t/* global window */\n\tif (typeof window === 'undefined') { return false; }\n\tfor (var k in window) {\n\t\ttry {\n\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\ttry {\n\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}());\nvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t/* global window */\n\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\treturn equalsConstructorPrototype(o);\n\t}\n\ttry {\n\t\treturn equalsConstructorPrototype(o);\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar keysShim = function keys(object) {\n\tvar isObject = object !== null && typeof object === 'object';\n\tvar isFunction = toStr.call(object) === '[object Function]';\n\tvar isArguments = isArgs(object);\n\tvar isString = isObject && toStr.call(object) === '[object String]';\n\tvar theKeys = [];\n\n\tif (!isObject && !isFunction && !isArguments) {\n\t\tthrow new TypeError('Object.keys called on a non-object');\n\t}\n\n\tvar skipProto = hasProtoEnumBug && isFunction;\n\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\ttheKeys.push(String(i));\n\t\t}\n\t}\n\n\tif (isArguments && object.length > 0) {\n\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\ttheKeys.push(String(j));\n\t\t}\n\t} else {\n\t\tfor (var name in object) {\n\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\ttheKeys.push(String(name));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hasDontEnumBug) {\n\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn theKeys;\n};\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\treturn (Object.keys(arguments) || '').length === 2;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tvar originalKeys = Object.keys;\n\t\t\tObject.keys = function keys(object) {\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t} else {\n\t\t\t\t\treturn originalKeys(object);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n",
    "'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n",
    "'use strict'\n\nfunction isArguments (obj) {\n  return Object.prototype.toString.call(obj) === '[object Arguments]'\n}\n\nmodule.exports = match\n\nfunction match (obj, pattern) {\n  return match_(obj, pattern, [], [])\n}\n\n/* istanbul ignore next */\nvar log = (/\\btmatch\\b/.test(process.env.NODE_DEBUG || '')) ?\n  console.error : function () {}\n\nfunction match_ (obj, pattern, ca, cb) {\n  log('TMATCH', typeof obj, pattern)\n  if (obj == pattern) {\n    log('TMATCH same object or simple value, or problem')\n    // if one is object, and the other isn't, then this is bogus\n    if (obj === null || pattern === null) {\n      return true\n\n    } else if (typeof obj === 'object' && typeof pattern === 'object') {\n      return true\n\n    } else if (typeof obj === 'object' && typeof pattern !== 'object') {\n      return false\n\n    } else if (typeof obj !== 'object' && typeof pattern === 'object') {\n      return false\n\n    } else {\n      return true\n    }\n\n  } else if (obj === null || pattern === null) {\n    log('TMATCH null test, already failed ==')\n    return false\n\n  } else if (typeof obj === 'string' && pattern instanceof RegExp) {\n    log('TMATCH string~=regexp test')\n    return pattern.test(obj)\n\n  } else if (typeof obj === 'string' && typeof pattern === 'string' && pattern) {\n    log('TMATCH string~=string test')\n    return obj.indexOf(pattern) !== -1\n\n  } else if (obj instanceof Date && pattern instanceof Date) {\n    log('TMATCH date test')\n    return obj.getTime() === pattern.getTime()\n\n  } else if (obj instanceof Date && typeof pattern === 'string') {\n    log('TMATCH date~=string test')\n    return obj.getTime() === new Date(pattern).getTime()\n\n  } else if (isArguments(obj) || isArguments(pattern)) {\n    log('TMATCH arguments test')\n    var slice = Array.prototype.slice\n    return match_(slice.call(obj), slice.call(pattern), ca, cb)\n\n  } else if (pattern === Buffer) {\n    log('TMATCH Buffer ctor')\n    return Buffer.isBuffer(obj)\n\n  } else if (pattern === Function) {\n    log('TMATCH Function ctor')\n    return typeof obj === 'function'\n\n  } else if (pattern === Number) {\n    log('TMATCH Number ctor (finite, not NaN)')\n    return typeof obj === 'number' && obj === obj && isFinite(obj)\n\n  } else if (pattern !== pattern) {\n    log('TMATCH NaN')\n    return obj !== obj\n\n  } else if (pattern === String) {\n    log('TMATCH String ctor')\n    return typeof obj === 'string'\n\n  } else if (pattern === Boolean) {\n    log('TMATCH Boolean ctor')\n    return typeof obj === 'boolean'\n\n  } else if (pattern === Array) {\n    log('TMATCH Array ctor', pattern, Array.isArray(obj))\n    return Array.isArray(obj)\n\n  } else if (typeof pattern === 'function' && typeof obj === 'object') {\n    log('TMATCH object~=function')\n    return obj instanceof pattern\n\n  } else if (typeof obj !== 'object' || typeof pattern !== 'object') {\n    log('TMATCH obj is not object, pattern is not object, false')\n    return false\n\n  } else if (obj instanceof RegExp && pattern instanceof RegExp) {\n    log('TMATCH regexp~=regexp test')\n    return obj.source === pattern.source &&\n      obj.global === pattern.global &&\n      obj.multiline === pattern.multiline &&\n      obj.lastIndex === pattern.lastIndex &&\n      obj.ignoreCase === pattern.ignoreCase\n\n  } else if (Buffer.isBuffer(obj) && Buffer.isBuffer(pattern)) {\n    log('TMATCH buffer test')\n    if (obj.equals) {\n      return obj.equals(pattern)\n    } else {\n      if (obj.length !== pattern.length) return false\n\n      for (var j = 0; j < obj.length; j++) if (obj[j] != pattern[j]) return false\n\n      return true\n    }\n\n  } else {\n    // both are objects.  interesting case!\n    log('TMATCH object~=object test')\n    var kobj = Object.keys(obj)\n    var kpat = Object.keys(pattern)\n    log('  TMATCH patternkeys=%j objkeys=%j', kpat, kobj)\n\n    // don't bother with stack acrobatics if there's nothing there\n    if (kobj.length === 0 && kpat.length === 0) return true\n\n    // if we've seen this exact pattern and object already, then\n    // it means that pattern and obj have matching cyclicalness\n    // however, non-cyclical patterns can match cyclical objects\n    log('  TMATCH check seen objects...')\n    var cal = ca.length\n    while (cal--) if (ca[cal] === obj && cb[cal] === pattern) return true\n    ca.push(obj); cb.push(pattern)\n    log('  TMATCH not seen previously')\n\n    var key\n    for (var l = kpat.length - 1; l >= 0; l--) {\n      key = kpat[l]\n      log('  TMATCH test obj[%j]', key, obj[key], pattern[key])\n      if (!match_(obj[key], pattern[key], ca, cb)) return false\n    }\n\n    ca.pop()\n    cb.pop()\n\n    log('  TMATCH object pass')\n    return true\n  }\n\n  /* istanbul ignore next */\n  throw new Error('impossible to reach this point')\n}\n",
    "/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    function realMethod(methodName) {\n        if (typeof console === undefinedType) {\n            return false; // We can't build a real method without a console to log to\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // these private functions always need `this` to be set properly\n\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n    }\n\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public API\n       *\n       */\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Package-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    return defaultLogger;\n}));\n",
    "/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\n(function(global){\n\n  // Passing in seed will seed this Noise instance\n  function Noise(seed) {\n    function Grad(x, y, z) {\n      this.x = x; this.y = y; this.z = z;\n    }\n\n    Grad.prototype.dot2 = function(x, y) {\n      return this.x*x + this.y*y;\n    };\n\n    Grad.prototype.dot3 = function(x, y, z) {\n      return this.x*x + this.y*y + this.z*z;\n    };\n\n    this.grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n                 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n                 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\n\n    this.p = [151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\n    // To remove the need for index wrapping, double the permutation table length\n    this.perm = new Array(512);\n    this.gradP = new Array(512);\n\n    this.seed(seed || 0);\n  }\n\n  // This isn't a very good seeding function, but it works ok. It supports 2^16\n  // different seed values. Write something better if you need more seeds.\n  Noise.prototype.seed = function(seed) {\n    if(seed > 0 && seed < 1) {\n      // Scale the seed out\n      seed *= 65536;\n    }\n\n    seed = Math.floor(seed);\n    if(seed < 256) {\n      seed |= seed << 8;\n    }\n\n    var p = this.p;\n    for(var i = 0; i < 256; i++) {\n      var v;\n      if (i & 1) {\n        v = p[i] ^ (seed & 255);\n      } else {\n        v = p[i] ^ ((seed>>8) & 255);\n      }\n\n      var perm = this.perm;\n      var gradP = this.gradP;\n      perm[i] = perm[i + 256] = v;\n      gradP[i] = gradP[i + 256] = this.grad3[v % 12];\n    }\n  };\n\n  /*\n  for(var i=0; i<256; i++) {\n    perm[i] = perm[i + 256] = p[i];\n    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n  }*/\n\n  // Skewing and unskewing factors for 2, 3, and 4 dimensions\n  var F2 = 0.5*(Math.sqrt(3)-1);\n  var G2 = (3-Math.sqrt(3))/6;\n\n  var F3 = 1/3;\n  var G3 = 1/6;\n\n  // 2D simplex noise\n  Noise.prototype.simplex2 = function(xin, yin) {\n    var n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin+yin)*F2; // Hairy factor for 2D\n    var i = Math.floor(xin+s);\n    var j = Math.floor(yin+s);\n    var t = (i+j)*G2;\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin-j+t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n      i1=1; j1=0;\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n      i1=0; j1=1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    var y1 = y0 - j1 + G2;\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    var y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n\n    var perm = this.perm;\n    var gradP = this.gradP;\n    var gi0 = gradP[i+perm[j]];\n    var gi1 = gradP[i+i1+perm[j+j1]];\n    var gi2 = gradP[i+1+perm[j+1]];\n    // Calculate the contribution from the three corners\n    var t0 = 0.5 - x0*x0-y0*y0;\n    if(t0<0) {\n      n0 = 0;\n    } else {\n      t0 *= t0;\n      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1*x1-y1*y1;\n    if(t1<0) {\n      n1 = 0;\n    } else {\n      t1 *= t1;\n      n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    var t2 = 0.5 - x2*x2-y2*y2;\n    if(t2<0) {\n      n2 = 0;\n    } else {\n      t2 *= t2;\n      n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70 * (n0 + n1 + n2);\n  };\n\n  // 3D simplex noise\n  Noise.prototype.simplex3 = function(xin, yin, zin) {\n    var n0, n1, n2, n3; // Noise contributions from the four corners\n\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin+yin+zin)*F3; // Hairy factor for 2D\n    var i = Math.floor(xin+s);\n    var j = Math.floor(yin+s);\n    var k = Math.floor(zin+s);\n\n    var t = (i+j+k)*G3;\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin-j+t;\n    var z0 = zin-k+t;\n\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if(x0 >= y0) {\n      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\n      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\n      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\n    } else {\n      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\n      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\n      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\n    }\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    var x1 = x0 - i1 + G3; // Offsets for second corner\n    var y1 = y0 - j1 + G3;\n    var z1 = z0 - k1 + G3;\n\n    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n    var y2 = y0 - j2 + 2 * G3;\n    var z2 = z0 - k2 + 2 * G3;\n\n    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n    var y3 = y0 - 1 + 3 * G3;\n    var z3 = z0 - 1 + 3 * G3;\n\n    // Work out the hashed gradient indices of the four simplex corners\n    i &= 255;\n    j &= 255;\n    k &= 255;\n\n    var perm = this.perm;\n    var gradP = this.gradP;\n    var gi0 = gradP[i+   perm[j+   perm[k   ]]];\n    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\n    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\n    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\n\n    // Calculate the contribution from the four corners\n    var t0 = 0.5 - x0*x0-y0*y0-z0*z0;\n    if(t0<0) {\n      n0 = 0;\n    } else {\n      t0 *= t0;\n      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1*x1-y1*y1-z1*z1;\n    if(t1<0) {\n      n1 = 0;\n    } else {\n      t1 *= t1;\n      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n    }\n    var t2 = 0.5 - x2*x2-y2*y2-z2*z2;\n    if(t2<0) {\n      n2 = 0;\n    } else {\n      t2 *= t2;\n      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n    }\n    var t3 = 0.5 - x3*x3-y3*y3-z3*z3;\n    if(t3<0) {\n      n3 = 0;\n    } else {\n      t3 *= t3;\n      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 32 * (n0 + n1 + n2 + n3);\n\n  };\n\n  // ##### Perlin noise stuff\n\n  function fade(t) {\n    return t*t*t*(t*(t*6-15)+10);\n  }\n\n  function lerp(a, b, t) {\n    return (1-t)*a + t*b;\n  }\n\n  // 2D Perlin Noise\n  Noise.prototype.perlin2 = function(x, y) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x), Y = Math.floor(y);\n    // Get relative xy coordinates of point within that cell\n    x = x - X; y = y - Y;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    X = X & 255; Y = Y & 255;\n\n    // Calculate noise contributions from each of the four corners\n    var perm = this.perm;\n    var gradP = this.gradP;\n    var n00 = gradP[X+perm[Y]].dot2(x, y);\n    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\n    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\n    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\n\n    // Compute the fade curve value for x\n    var u = fade(x);\n\n    // Interpolate the four results\n    return lerp(\n        lerp(n00, n10, u),\n        lerp(n01, n11, u),\n       fade(y));\n  };\n\n  // 3D Perlin Noise\n  Noise.prototype.perlin3 = function(x, y, z) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\n    // Get relative xyz coordinates of point within that cell\n    x = x - X; y = y - Y; z = z - Z;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    X = X & 255; Y = Y & 255; Z = Z & 255;\n\n    // Calculate noise contributions from each of the eight corners\n    var perm = this.perm;\n    var gradP = this.gradP;\n    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\n    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\n    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\n    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\n    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\n    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\n    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\n    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\n\n    // Compute the fade curve value for x, y, z\n    var u = fade(x);\n    var v = fade(y);\n    var w = fade(z);\n\n    // Interpolate\n    return lerp(\n        lerp(\n          lerp(n000, n100, u),\n          lerp(n001, n101, u), w),\n        lerp(\n          lerp(n010, n110, u),\n          lerp(n011, n111, u), w),\n       v);\n  };\n\n  global.Noise = Noise;\n\n})(typeof module === \"undefined\" ? this : module.exports);\n",
    "\r\n/* globals -game */\r\n/* globals -director */\r\n/* globals -inspect */\r\n/* globals -CONST */\r\n/* globals window */\r\n/* exported inspect */\r\n\r\nimport log from 'loglevel';\r\nimport expect from 'expect';\r\n\r\nimport AssetManager from 'lib/AssetManager';\r\n\r\nimport Play from 'states/Play';\r\n\r\n//====== Global objects accessible from all modules ======\r\nvar game;         //Phaser.Game instance\r\n\r\n//var Phaser;       //Phaser library object\r\n/* globals -g */\r\nvar g = {};       //display layers\r\n\r\n/* exported nextId */\r\nvar idCounter = 0;\r\n//Generate next unique ID\r\nfunction nextId() { return ++idCounter; }\r\n\r\n//========================================================\r\n// ENTRYPOINT\r\n\r\n//init globals\r\n\r\ngame = new Phaser.Game(1024, 550, Phaser.AUTO, 'konkr');\r\n\r\nvar env = {\r\n    log: log,\r\n    game: game,\r\n    debugMode: 1\r\n};\r\nwindow.env = env;\r\n\r\nenv.assetManager = new AssetManager(env);\r\n\r\n//default loglevel\r\nlog.setDefaultLevel(log.levels.DEBUG);\r\nlog.setLevel(log.levels.DEBUG);\r\n\r\n//========================================================\r\n// GAME STATE: Init\r\n\r\nvar Boot = function(game) {\r\n};\r\nBoot.prototype= {\r\n    preload: function() {\r\n\r\n    },\r\n\r\n    create: function() {\r\n        game.state.start(\"PrepareLevel\");\r\n    }\r\n};\r\n\r\n\r\n//========================================================\r\n// GAME STATE: Level Select\r\n/*\r\nvar LevelSelect = function(game) {\r\n    this.levels = new LevelCollection();\r\n};\r\nLevelSelect.prototype = {\r\n    preload: function() {\r\n        this.game.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;\r\n\r\n        game.load.spritesheet('menu-item','assets/menu-item.png',344,24);\r\n    },\r\n    create: function(game) {\r\n        var self = this;\r\n        var MENU_ITEM_HEIGHT = 24;\r\n        var MENU_ITEM_SPACING = 8;\r\n        var TEXT_PADDING = 4;\r\n        var y = MENU_ITEM_SPACING;\r\n\r\n        game.debug.stop();\r\n\r\n        this.levels.load(\"level/list.txt\", listLoaded);\r\n        function listLoaded() {\r\n            if (localStorage.lastLevel && self.levels.levelExists(localStorage.lastLevel)) {\r\n                selectLevel(localStorage.lastLevel);\r\n                return;\r\n            } \r\n\r\n            self.levels.list.forEach(function(level){\r\n                game.add.button(MENU_ITEM_SPACING, y, 'menu-item', function() { selectLevel(level); }, this, 1, 0);\r\n                game.add.text(MENU_ITEM_SPACING+TEXT_PADDING, y + TEXT_PADDING, level, {font: \"16px Arial\", fill:'white'});\r\n                y+= MENU_ITEM_HEIGHT + MENU_ITEM_SPACING;\r\n            });        \r\n        }\r\n        \r\n        function selectLevel(level) {\r\n            self.levels.getLevel(level, levelLoaded);\r\n            log.info(\"Loading level '\"+ level+ \"'...\");\r\n            localStorage.lastLevel = level;\r\n        }\r\n\r\n        function levelLoaded(cfg) {\r\n            game.state.start(\"PrepareLevel\", true, false, cfg);\r\n        }\r\n    }\r\n\r\n};\r\n*/\r\n//========================================================\r\n// GAME STATE: PrepareLevel\r\nvar PrepareLevel = function(game) {\r\n    this.level = null;\r\n};\r\nPrepareLevel.prototype = {\r\n    init: function(levelCfg) {\r\n        /*log.trace(\"Intializing level configuration\", levelCfg);\r\n        applyCfg(levelCfg);\r\n        this.dictionaryReady = false;\r\n        this.loadingPhase = \"Připravuji slovník...\";\r\n        var self = this;\r\n        //Load level dictionary\r\n        //Dictionary.get().onReady.addOnce(function(){self.dictionaryReady=true;});\r\n        this.hndLoadingProgress = Dictionary.get().onLoadingProgress.add(function(done,total) { \r\n            var perc = Math.floor(done / total * 100);\r\n            self.loadingPhase = \"Připravuji slovník (\"+perc+\"%)\"; \r\n        });*/\r\n    },\r\n\r\n    preload: function() {\r\n        //Shared assets\r\n        env.assetManager.load('hex');\r\n    },\r\n\r\n    create: function(game) {\r\n        var txt = game.add.text(game.width/2,game.height/2,\"Načítám...\",{fill:\"white\"});\r\n        txt.anchor.set(0.5);\r\n        this.lblLoadingPhase = game.add.text(game.world.width/2,game.world.height/2+60,\"...\",{fill:\"white\", font:\"16px Arial\"});\r\n        this.lblLoadingPhase.anchor.set(0.5);\r\n    },\r\n\r\n    update: function() {\r\n        this.lblLoadingPhase.destroy();\r\n        game.state.start(\"Play\", true, false, env);\r\n    },\r\n\r\n    render: function() {\r\n    }\r\n};\r\n\r\n//========================================================\r\n// GAME STATE: GameOver\r\n/*\r\nvar GameOver = function(game) {\r\n    this.level = null;\r\n};\r\nGameOver.prototype = {\r\n    init: function(score) {\r\n        this.finalScore = score;\r\n    },\r\n    preload: function() {\r\n    },\r\n\r\n    create: function(game) {\r\n        var txt = game.add.text(game.world.width/2,game.world.height/2,\"Seš mrtvej!\",{fill:\"white\"});\r\n        txt.anchor.set(0.5);\r\n        if (this.finalScore) {\r\n            this.lblLoadingPhase = game.add.text(game.world.width/2,game.world.height/2+40,\"Ušel jsi \"+ this.finalScore +\" kroků\",{fill:\"white\", font:\"16px Arial\"});\r\n            this.lblLoadingPhase.anchor.set(0.5);\r\n        }\r\n        game.time.events.add(2000,function() { game.state.start(\"LevelSelect\"); });\r\n    },\r\n\r\n    update: function() {\r\n    },\r\n\r\n    render: function() {\r\n    }\r\n};\r\n*/\r\n\r\ngame.state.add(\"Boot\",Boot);\r\ngame.state.add(\"PrepareLevel\",PrepareLevel);\r\ngame.state.add(\"Play\",Play);\r\nconsole.log(Play);\r\ngame.state.start(\"Boot\");\r\n\r\n",
    "/* exported AssetManager */\r\n/* globals -AssetManager */\r\n\r\nimport { HEX_WIDTH, HEX_HEIGHT } from 'lib/Renderer';\r\n\r\nclass AssetManager {\r\n    constructor({game, log}) {\r\n        this.game = game;\r\n        this.log = log;\r\n\r\n    }\r\n\r\n    load(id) {\r\n        const game = this.game;\r\n        var args;\r\n        if (AssetManager.images[id]) {\r\n            args = [id].concat(AssetManager.images[id]);\r\n            game.load.image.apply(game.load,args);\r\n        } else if (AssetManager.spritesheets[id]) {\r\n            args = [id].concat(AssetManager.spritesheets[id]);\r\n            game.load.spritesheet.apply(game.load,args);\r\n        } else {\r\n            log.error(\"Unknown asset requested:\",id);\r\n        }\r\n    }\r\n}\r\n\r\nAssetManager.images = {\r\n    'control-panel': ['assets/control-panel.png'],\r\n    'stolenBackground': ['assets/stolen-background.png']\r\n};\r\n\r\nAssetManager.spritesheets = {\r\n    'hex' : ['assets/hex.png', HEX_WIDTH, 41],\r\n};\r\n\r\nexport default AssetManager;",
    "import log from 'loglevel';\r\nimport expect from 'expect';\r\n\r\n// A coordinates in the hexagonal grid.\r\n// automatically converts between three coordinate systems\r\n// - ordinal: (index, rowrowSize) position of hex in a 1D array organized by rows\r\n// - axial: (r,c) coordinates in hex map (r = row, c = column (column axis on hex grid goes down and sligthly left))\r\n// - spatial: (x,y) coordinates on screen\r\nclass GridPoint {\r\n    // index = index in single-dimensional row-major array of hexes\r\n    // rowSize = number of hexes per row in the array\r\n    constructor({x,y,r,c,index,rowSize}) {\r\n        expect(rowSize).toBeA('number');\r\n        if (x !== undefined && y !== undefined) {\r\n            this._axial = { r: 2*(y-x), c: y};\r\n        } else if (r !== undefined && c !== undefined) {\r\n            this._axial = { r: r };\r\n        } else if (index !== undefined && rowSize !== undefined) {\r\n            this._index = index;\r\n        } else {\r\n            log.error('Invalid coordinates specification for creating a GridPoint ',{x:x,y:y,r:r,c:c,index:index,rowSize:rowSize});\r\n        }\r\n        this._rowSize = rowSize;\r\n    }\r\n\r\n    // Index in array of all gridpoints on map\r\n    get index() {\r\n        if (this._index === undefined) {\r\n            this._index = this.r * this._rowSize + this.c - Math.floor(this.r/2);\r\n        }\r\n        return this._index;\r\n    }\r\n\r\n    // Axial coordinates in hexagonal grid\r\n    get axial() {\r\n        if (this._axial === undefined) {\r\n            let r = Math.floor(this._index / this._rowSize);\r\n            this._axial = {r: r, c:Math.floor(this._index  % this._rowSize + Math.floor(r/2))};\r\n        }\r\n        return this._axial;\r\n    }\r\n\r\n\r\n    // row in hexagonal grid\r\n    get r() {\r\n        return this.axial.r;\r\n    }\r\n\r\n    // \"column\" (line going down and left) in the hexagonal grid\r\n    get c() {\r\n        return this.axial.c;\r\n    }\r\n\r\n    // horizontal coordinate for display\r\n    get x() {\r\n        return this.c - this.r/2;\r\n    }\r\n\r\n    // vertical coordinate for display\r\n    get y() {\r\n        return this.r;\r\n    }\r\n\r\n    toString() {\r\n        return(`[GridPoint ${this.index} (${this.r},${this.c})]`);\r\n    }\r\n\r\n}\r\n\r\nconst HEX_ADJACENCY_VECTORS = [[-1,-1],[-1,0],[0,1],[1,1],[1,0],[0,-1]];\r\n\r\nclass Hexagon {\r\n    constructor(grid,gridPoint) {\r\n        this.position = gridPoint;\r\n        this.grid = grid;\r\n    }\r\n\r\n    toString() {\r\n        return `[Hex at ${this.position}]`;\r\n    }\r\n\r\n    neighbours() {\r\n        const {r,c} = this.position;\r\n        return HEX_ADJACENCY_VECTORS\r\n            .map((change) => this.grid.getHexByAxial(r+change[0], c+change[1]))\r\n            .filter((hex) => hex.exists());        \r\n    }\r\n\r\n    floodFill(condition) {\r\n        const res = new HexGroup([this]);\r\n        res.floodFill(condition);\r\n        return res;\r\n    }\r\n\r\n    get id() {\r\n        return this.position.index;\r\n    }\r\n\r\n    exists() { return true; }\r\n}\r\n\r\nclass HexGroup {\r\n    constructor(hexes) {\r\n        this.members=[];\r\n        this._size = 0;\r\n        if (hexes) this.addAll(hexes);\r\n    }\r\n\r\n    contains(hex) {\r\n        return !!this.members[hex.id];\r\n    }\r\n\r\n    containsId(id) {\r\n        return !!this.members[id];\r\n    }\r\n\r\n    getById(id) {\r\n        return this.members[id];\r\n    }\r\n\r\n    add(hex) {\r\n        if (this.members[hex.id]) return false;\r\n        this.members[hex.id] = hex;\r\n        ++this._size;\r\n        return true;\r\n    }\r\n\r\n    addAll(hexes) {\r\n        hexes.forEach(hex=>this.add(hex));\r\n    }\r\n\r\n    remove(hex) {\r\n        if (this.members[hex.id] === undefined) return;\r\n        this.members[hex.id] = undefined;\r\n        --this._size;\r\n    }\r\n\r\n    forEach(fn) {\r\n        return this.members.forEach(fn);\r\n    }\r\n\r\n    clone() {\r\n        return new HexGroup(this.members);\r\n    }\r\n\r\n    clear() {\r\n        this.members = [];\r\n    }\r\n\r\n    get size() {\r\n        return this._size;\r\n    }\r\n\r\n    floodFill(condition = ()=>true) {\r\n        let pending = this.clone(); \r\n\r\n        let nextPending;\r\n        const processHex = hex => {\r\n                this.add(hex);\r\n                nextPending.addAll(hex.neighbours().filter(filterCondition));\r\n        };\r\n        const filterCondition = hex=>condition(hex) && !this.contains(hex);\r\n        while (pending.size > 0) {\r\n            //log.debug(\"Pending:\"+ pending.toString());\r\n            nextPending = new HexGroup();\r\n            pending.forEach(processHex);\r\n            pending = nextPending;\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        return `[HexGroup (${this.size}): ${this.members.map(hex=>`#${hex.id}`).filter(a=>a!==undefined).join(\",\")}]`;\r\n    }\r\n}\r\n\r\nclass HexGrouping {\r\n    constructor() {\r\n        this.groups = {};\r\n        this.membership = [];\r\n        this._size = 0;\r\n    }\r\n\r\n    add(hex, key) {\r\n        if (this.membership[hex.id]) {\r\n            if (this.membership[hex.id] === key) return;\r\n            this.groups[key].remove(hex);\r\n        } else {\r\n            ++this._size;\r\n        }\r\n        if (!this.groups[key]) this.groups[key] = new HexGroup();\r\n        this.groups[key].add(hex);\r\n        this.membership[hex.id] = key;\r\n    }\r\n\r\n    addAll(hexes, key) {\r\n        hexes.forEach(hex => this.add(hex, key));\r\n    }\r\n\r\n    getOwnerOf(hex) {\r\n        expect(hex).toExist();\r\n        return this.membership[hex.id];\r\n    }\r\n\r\n    forEach(fn) {\r\n        for (const key in this.groups) {\r\n            fn(key, this.groups[key]);\r\n        }\r\n    }\r\n\r\n    getLargestGroup() {\r\n        var max = 0;\r\n        var res = null;\r\n        this.forEach((key,hexGroup) => {\r\n            if (hexGroup.size > max) {\r\n                max = hexGroup.size;\r\n                res = hexGroup;\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    get size() {\r\n        return this._size;\r\n    }\r\n\r\n    toString() {\r\n        let total=0;\r\n        let str = Object.keys(this.groups).map((key) => {\r\n            console.log(\"==\",key,this.groups[key].size);\r\n            const len = this.groups[key].size;\r\n            total += len;\r\n            return `${key}(${len})`;\r\n        }).join(\", \");\r\n        return `[HexGrouping (${total}): ${str}]`;\r\n    }\r\n}\r\n\r\nclass HexGrid {\r\n\r\n    constructor(width, height) {\r\n        this.hexes = [];\r\n        this.width = width;\r\n        this.height = height;\r\n        this.upperBound = width * height;\r\n    }\r\n\r\n    fillWith(fn) {\r\n        for (let i = 0; i < this.upperBound; ++i) {\r\n            var p = new GridPoint({index: i, rowSize: this.width});\r\n            this.hexes[i] = (fn(p) ? new Hexagon(this,p) : null );\r\n        }\r\n    }\r\n\r\n    // point = GridPoint instance\r\n    getHexByAxial(r,c) {\r\n        if (c >= this.width - 0.5 + r/2 || c - r/2 <= -1) return NullHex;\r\n        if (r >= this.height) return NullHex;\r\n        const i = r * this.width + c - Math.floor(r/2);\r\n        return this.hexes[i] || NullHex;\r\n    }\r\n\r\n    forEach(fn) {\r\n        return this.hexes.forEach(hex => {\r\n            if (hex) fn(hex);\r\n        });\r\n    }\r\n\r\n    destroyHexes(hexes) {\r\n        hexes.forEach(hex => {\r\n            this.hexes[hex.position.index] = null;\r\n        });\r\n    }\r\n\r\n    components(categoryFunction=()=>true) {\r\n        let comps = new HexGrouping();\r\n        let compNumber = 1;\r\n        this.forEach(hex => {\r\n            if (!comps.getOwnerOf(hex)) {\r\n                log.debug(\"-> \"+hex.toString());\r\n                comps.add(hex, compNumber);\r\n                comps.addAll(hex.floodFill(categoryFunction), compNumber);\r\n                ++compNumber;\r\n            }\r\n        });\r\n        return comps;\r\n    }\r\n\r\n    dump() {\r\n        let str = \"\";\r\n        for (let r = 0; r < this.height; ++r) {\r\n            for (let c = 0; c < this.width; ++c) {\r\n                str+=(this.hexes[r*this.height+c]===null?\" \":\"X\");\r\n            }\r\n            str += \"\\n\";\r\n        }\r\n        return str;\r\n    }\r\n\r\n    static test() {\r\n        let grid = new HexGrid(4,6);\r\n        log.debug(\"4x6 world\");\r\n        grid.forEach(function(hex) {\r\n            log.debug(\"Visited hex \" + hex.toString());\r\n        });\r\n    }\r\n}\r\n\r\nconst NullHex = {\r\n    toString: () => \"[Null Hex]\",\r\n    neighbours: () => [],\r\n    id: -1,    \r\n    exists: () => false,\r\n    position: {\r\n        x: -1, \r\n        y: -1, \r\n        r: -1,\r\n        c: -1,\r\n        index: -1,\r\n        toString: () => \"[Null GridPoint]\"\r\n    },\r\n    floodFill: () => new HexGroup()\r\n};\r\n\r\nexport { HexGrid };\r\n\r\n",
    "import log from 'loglevel';\r\nimport expect from 'expect';\r\nimport { OrderedHashMap } from 'lib/util';\r\n\r\nconst HEX_WIDTH = 32;\r\nconst HEX_HEIGHT = 37;\r\nconst HEX_SIZE = HEX_HEIGHT/2;\r\nconst OFFSET_TOP = 10;\r\nconst OFFSET_LEFT = 10 + HEX_WIDTH/2;\r\n\r\nconst LINE_HEIGHT = HEX_HEIGHT * 3/4;\r\n\r\n\r\n\r\n\r\nclass Ground {\r\n    constructor(env) {\r\n        const {game, grid} = env;\r\n        expect(game).toExist();\r\n        expect(grid).toExist();\r\n        this.grid = grid;\r\n        this.game = game;\r\n        this.group = game.add.group();\r\n        this.tileToSprite = {};\r\n        this.grid.forEach((hex) => {\r\n            var sprite = new GroundTileSprite(env,hex);\r\n            this.group.add(sprite);\r\n            this.tileToSprite[hex.id] = sprite;\r\n        });\r\n\r\n        this.highlightedTiles = [];\r\n    }\r\n\r\n    getGroup() {\r\n        return this.group;\r\n    }\r\n\r\n    highlightTiles(tiles) {\r\n        var self = this;\r\n        this.highlightedTiles.forEach((tileSprite) => {\r\n            if (tileSprite) tileSprite.frame = 0;\r\n        });\r\n        this.highlightedTiles = tiles.map((tile) => tile && self.tileToSprite[tile.id]);\r\n        this.highlightedTiles.forEach((tileSprite) => {\r\n            if (tileSprite) tileSprite.frame = 1;\r\n        });\r\n    }\r\n}\r\n\r\nclass GroundTileSprite extends Phaser.Sprite {\r\n    constructor({game, log},tile) {\r\n        const x = OFFSET_LEFT + tile.position.x * HEX_WIDTH;\r\n        const y = OFFSET_TOP + tile.position.y * LINE_HEIGHT;\r\n        super(game, x, y, 'hex');\r\n        //log.debug(`Hex sprite for ${tile} created at ${x}:${y}`);\r\n    \r\n        /*\r\n        var style = { font: \"10px Courier New\", fill: \"white\", align: \"center\"};\r\n        this.label = game.add.text(HEX_WIDTH/2,HEX_HEIGHT/2,tile.id + \"\\n\" + tile.position.r + \",\" + tile.position.c, style);\r\n        this.label.lineSpacing = -6;\r\n        this.label.anchor.set(0.5,0.5);\r\n        this.addChild(this.label);\r\n        */\r\n    }\r\n}\r\n\r\nclass DebugInfo {\r\n    constructor({game}) {\r\n        this.game = game;\r\n        this.items = new OrderedHashMap();\r\n    }\r\n\r\n    set(key,value) {\r\n        this.items.push(key,value);\r\n    }\r\n\r\n    render() {\r\n        let y = 32;\r\n        this.items.forEach((key, value) => {\r\n            this.game.debug.text(key + \": \" + value,32,y);\r\n            y +=32;\r\n        });\r\n    }\r\n}\r\n\r\nexport { Ground, DebugInfo, HEX_WIDTH, HEX_HEIGHT, LINE_HEIGHT };",
    "import noisejs from 'noisejs';\r\n\r\n\r\nfunction worldGenSolid({grid,log,tileFactory}) {\r\n    grid.fillWith((p)=> true);\r\n}\r\n\r\nfunction worldGenPerlin({grid,log,tileFactory}) {\r\n    const MIN_SIZE = 150;\r\n    const SMOOTHNESS = 7;\r\n\r\n    let noise, comps, largest, tries, seed;\r\n    const generatorFunc = (p=>{\r\n        return (noise.simplex2(p.x/SMOOTHNESS,p.y/SMOOTHNESS) + 1) * avoidEdges(p.x/grid.width,p.y/grid.height) >=0.75;\r\n    });\r\n\r\n\r\n    do {\r\n        seed = Math.floor(Math.random()*65535);\r\n        noise = new noisejs.Noise();\r\n        grid.fillWith(generatorFunc);\r\n        comps = grid.components();\r\n        largest = comps.getLargestGroup();\r\n        ++tries;\r\n        if (tries > 50) throw Error('Failed to generate suitable world after 50 iterations');\r\n    } while (largest.size < MIN_SIZE);\r\n\r\n    comps.forEach((groupId,hexGroup)=>{\r\n        if (hexGroup!=largest) {\r\n            grid.destroyHexes(hexGroup);\r\n        }\r\n    });\r\n\r\n    log.info(\"Map generated (seed=\"+seed+\")\");\r\n\r\n}\r\n\r\n// x and y shoudl be between 0 and 1\r\n// returns 1 for center (0.5;0.5) and approaches zero when going further from center (return 0 in corners such as 0;0, 1;0)\r\nfunction avoidEdges(x,y) {\r\n    return 1 - ((0.5-x)*(0.5-x)+(0.5-y)*(0.5-y))*2;\r\n}\r\n\r\nwindow.avoidEdges = avoidEdges;\r\n\r\nexport { worldGenPerlin, worldGenSolid };",
    "import { HEX_WIDTH, HEX_HEIGHT, LINE_HEIGHT } from 'lib/Renderer'\r\n\r\nclass TileSelectionProxy extends Phaser.Image {\r\n    constructor({game,grid,debug,ground,log}) {\r\n        super(game,10,10);\r\n\r\n        this.debug = debug;\r\n        this.game = game;\r\n        this.grid = grid;\r\n        this.ground = ground;\r\n        this.active = false;\r\n        this.fixedToCamera = true;\r\n        this.width = game.width - 2 * 10;\r\n        this.height = game.height - 2 * 10;\r\n        this.inputEnabled = true;\r\n        \r\n        this.events.onInputOver.add(() => this.active = true);\r\n        this.events.onInputOut.add(() => this.active = false);\r\n        this.events.onInputDown.add(() => {\r\n            log.info(this.getHexUnderCursor().toString(),this.getHexUnderCursor());\r\n        });\r\n    }\r\n\r\n    update() {\r\n        super.update(...arguments);\r\n        if (this.active) {\r\n            this.ground.highlightTiles(this.getHexUnderCursor().neighbours());\r\n        }\r\n    }\r\n\r\n    getHexUnderCursor() {\r\n        let x = (this.game.input.mousePointer.worldX - 10) / HEX_WIDTH;\r\n        let y = (this.game.input.mousePointer.worldY - 10) / LINE_HEIGHT;\r\n\r\n        let dx = x % 1;\r\n        let dy = y % 1;\r\n\r\n        let centerX, centerY;\r\n\r\n        //this.debug.set(\"pointer-at\",x.toFixed(2) + \",\" +y.toFixed(2));\r\n\r\n        if (Math.floor(y) % 2) {\r\n            //A\r\n            if (dx < 0.5) {\r\n                if (dy < (1-(2*dx))/3) {\r\n                    //this.debug.set(\"section\",\"top-left\");\r\n                    centerX = Math.floor(x);\r\n                    centerY = Math.floor(y) - 1/3;\r\n                } else {\r\n                    //this.debug.set(\"section\",\"bottom\");\r\n                    centerX = Math.floor(x) + 0.5;\r\n                    centerY = Math.floor(y) + 2/3;\r\n                }\r\n            } else {\r\n                if (dy < 1/3-(2*(1-dx)/3)) {\r\n                    //this.debug.set(\"section\",\"top-right\");\r\n                    centerX = Math.floor(x) + 1;\r\n                    centerY = Math.floor(y) - 1/3;\r\n                } else {\r\n                    //this.debug.set(\"section\",\"bottom\");\r\n                    centerX = Math.floor(x) + 0.5;\r\n                    centerY = Math.floor(y) + 2/3;\r\n                }\r\n            }\r\n        } else {\r\n            //B\r\n            if (dx < 0.5) {\r\n                if (dy < (2*dx)/3) {\r\n                    //this.debug.set(\"section\",\"top\");\r\n                    centerX = Math.floor(x) + 1/2;\r\n                    centerY = Math.floor(y) - 1/3;\r\n                } else {\r\n                    //this.debug.set(\"section\",\"bottom-left\");\r\n                    centerX = Math.floor(x);\r\n                    centerY = Math.floor(y) + 2/3;\r\n                }\r\n            } else {\r\n                if (dy < 2/3-(2*(dx)/3)) {\r\n                    //this.debug.set(\"section\",\"top\");\r\n                    centerX = Math.floor(x) + 1/2;\r\n                    centerY = Math.floor(y) - 1/3;\r\n                } else {\r\n                    //this.debug.set(\"section\",\"bottom-right\");\r\n                    centerX = Math.floor(x) + 1;\r\n                    centerY = Math.floor(y) + 2/3;\r\n                }\r\n            }                \r\n        }\r\n\r\n        centerX = centerX - 1;\r\n        centerY = centerY - 2/3;\r\n        let r = Math.round(centerY);\r\n        let c = Math.round(centerX + (centerY / 2)); \r\n\r\n        return this.grid.getHexByAxial(r,c);\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default TileSelectionProxy;",
    "//converts string like \"Exponential.InOut\" to the matching function from Phaser.Easing \r\nfunction easing(str) {\r\n    var s = str.split(\".\");\r\n    expect(s.length).toBe(2, \"Invalid easing function ID: \"+str);\r\n    return Phaser.Easing[s[0]][s[1]];\r\n}\r\n\r\n//extend(base,child) ... recursively adds properties from child object to base object\r\nfunction extend(base, child, stack) {\r\n    expect(base).toBeA('object', 'invalid base object');\r\n    expect(child).toBeA('object', 'invalid extender');\r\n    stack = stack || \"\";\r\n    for (var key in child) {\r\n        if (child.hasOwnProperty(key)) {\r\n            if (typeof base[key] === 'object') {\r\n                if (typeof child[key]!== 'object') {\r\n                    log.error('invalid extension of ' + stack + \".\"+key+\": cannot replace object by non-object\");\r\n                    return false;\r\n                }\r\n                extend(base[key], child[key], stack+\".\"+key);\r\n            } else {\r\n                base[key] = child[key];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction onFirefox() {\r\n    return (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 );\r\n}\r\n\r\n\r\nclass OrderedHashMap {\r\n    constructor() {\r\n        this._keys = [];\r\n        this._vals = {};\r\n    }\r\n\r\n    push(k,v) {\r\n        if (this._vals[k] === undefined) this._keys.push(k);\r\n        this._vals[k] = v;\r\n    }\r\n\r\n    insert(pos,k,v) {\r\n        if (this._vals[k] === undefined) {\r\n            this._keys.splice(pos,0,k);\r\n            this._vals[k] = v;\r\n        }\r\n    }\r\n\r\n    forEach(fn) {\r\n        this.keys.forEach((k) => fn(k,this._vals[k]));\r\n    }\r\n\r\n    get(k) { \r\n        return this._vals[k]; \r\n    }\r\n\r\n    get length() {\r\n        return this._keys.length;\r\n    }\r\n\r\n    get keys() {\r\n        return this._keys;\r\n    }\r\n\r\n    get values() {\r\n        return this._keys.map(k => this._vals[k]);\r\n    }\r\n};\r\n\r\nwindow.OrderedHashMap = OrderedHashMap;\r\n\r\n//==================\r\n// CHEATS\r\nvar Cheat = {\r\n    search : function(sequence) {\r\n        return Dictionary.get()._impl.search(sequence,20);\r\n    },\r\n    lifes : function(amount) {\r\n        inspect.director.addLifes(amount);\r\n    }\r\n};\r\n\r\n//==================\r\n// CACHE\r\n\r\nvar Cache = function(func, context, limit) {\r\n    expect(func).toBeA('function');\r\n    this.func = func;\r\n    this.context = context;\r\n    this.data = {};\r\n    this.dataQueue = [];\r\n    this.limit = limit;\r\n};\r\n\r\nCache.prototype.get = function (key, callback) {\r\n    if (this.data[key]) {\r\n        log.debug(\"CACHE HIT\", key);\r\n        return callback.apply(this,this.data[key]);\r\n    }\r\n    var self = this;\r\n    log.debug(\"CACHE MISS\", key);\r\n    this.func(key,processResult);\r\n    function processResult() {\r\n        self.data[key] = arguments;\r\n        self.dataQueue.push(key);\r\n        while (self.dataQueue.length > self.limit) {\r\n            self.invalidate(self.dataQueue.shift());\r\n        }\r\n        callback.apply(self,arguments);\r\n    }\r\n};\r\n\r\nCache.prototype.invalidate = function(key) {\r\n    delete(this.data[key]);\r\n};\r\n\r\nCache.test = function() {\r\n    function f(x,callback) {\r\n        callback(x, x*x, x+x);\r\n    }\r\n\r\n    var func = new Cache(f,this,3);\r\n    func.get(1, log.debug);\r\n    func.get(2, log.debug);\r\n    func.get(3, log.debug);\r\n    func.get(1, log.debug);\r\n    func.get(3, log.debug);\r\n    func.get(4, log.debug);\r\n    func.get(1, log.debug);\r\n    func.get(1, log.debug);\r\n    func.get(2, log.debug);\r\n};\r\n\r\n\r\n//==================\r\n// RANDOMIZERS\r\n\r\nvar Random = {\r\n    oneOf: function(array) {\r\n        return array[Random.integer(0,array.length)];\r\n    },\r\n    property: function(obj) {\r\n        var result;\r\n        var count = 0;\r\n        for (var prop in obj)\r\n            if (Math.random() < 1/++count)\r\n               result = prop;\r\n        return result;\r\n    },\r\n    integer: function(from, to) {\r\n        return Math.floor(Math.random()*(to-from))+from;\r\n    },\r\n    substring: function(str, length) {\r\n        length = length || Random.integer(1,str.length);\r\n        var start = Random.integer(0,str.length-length);\r\n        return str.substring(start, start+length);\r\n    }\r\n};\r\nRandom.Selector = function Selector() {\r\n    this.list = [];\r\n    this.total = 0;\r\n};\r\n\r\nRandom.Selector.prototype.add = function (item, weight) {\r\n    this.list.push({item:item, weight:weight});\r\n    this.total += weight;\r\n};\r\nRandom.Selector.prototype.pickOne = function () {\r\n    if (!this.list.length) {\r\n        log.warn(\"Attempted to pick an item from an empty Random.Selector.\");\r\n        return null;\r\n    }\r\n    var result = Math.random()*this.total;\r\n    var sum = 0;\r\n    var i = 0;\r\n    while (sum < result) {\r\n        sum += this.list[i++].weight;\r\n    }\r\n    return this.list[Math.max(0, i-1)].item;\r\n};\r\n\r\nRandom.Selector.test = function() {\r\n    var s = new Random.Selector();\r\n    s.add(\"A\",1);\r\n    s.add(\"B\",2);\r\n    s.add(\"C\",3);\r\n\r\n    var results = {\r\n        A:0, B:0, C:0\r\n    };\r\n    for (var n = 1; n<100000; ++n) {\r\n        ++results[s.pickOne()];\r\n    }\r\n    log.debug(\"Results: \", s, results);\r\n};\r\n/*\r\nvar a = { a: { a1: 1, a2: 2}, b:'b' }\r\nvar b = { a: { a1: 3 } }\r\n\r\nextend(a,b);\r\nconsole.debug(\"TEST1:\",a);\r\n*/\r\n\r\n\r\nexport { OrderedHashMap };",
    "import expect from 'expect';\r\n\r\nimport { HexGrid } from 'lib/HexGrid';\r\nimport { Ground, DebugInfo } from 'lib/Renderer';\r\nimport TileSelectionProxy from 'lib/ui/TileSelectionProxy';\r\nimport { worldGenPerlin, worldGenSolid } from 'lib/WorldGenerator';\r\n\r\nclass Play {\r\n    constructor(game) {\r\n        this.game = game;\r\n    }\r\n\r\n    init(env) {\r\n        const {game, log, debugMode} = env;\r\n        expect(game).toExist();\r\n        expect(log).toExist();\r\n\r\n        this.debugMode = debugMode;\r\n        this.debug = new DebugInfo(env);\r\n        env.debug = this.debug;\r\n        const grid = new HexGrid(30,18);\r\n        env.grid = grid;\r\n        \r\n        worldGenPerlin(env);\r\n\r\n        this.ground = new Ground(env);\r\n        env.ground = this.ground;\r\n\r\n        let g = {};\r\n        //display layers hierarchy\r\n        g.root = game.add.group();                                  \r\n            g.staticBackground = g.root.add(game.add.group());      // static background (does not move with the world)\r\n            g.world = g.root.add(game.add.group());                 // the scrolling game world\r\n                g.terrain = this.ground.getGroup();          // terrain tiles in the scrolling game world\r\n                g.underObjects = g.world.add(game.add.group());     // elements displayed between terrain and objects in the scrolling game world\r\n                g.objects = g.world.add(game.add.group());          // objects placed on terrain in the game world\r\n                g.overObjects = g.world.add(game.add.group());      // elements overlayed over objects in the game world\r\n                g.tileSelectionProxy = g.world.add(new TileSelectionProxy(env)); // invisible sprite capturing mouseover/mousedown items on game world and translating them to events on individual hexagons\r\n            g.UIbackground = g.root.add(game.add.group());\r\n            g.UI = g.root.add(game.add.group());\r\n  \r\n        // A simple background    \r\n        /*\r\n        var bg = g.staticBackground.create(0, 0, CFG.world.background);\r\n        bg.width = game.width;\r\n        bg.scale.y = bg.scale.x;\r\n        bg.y=game.world.height-120-bg.height;*/\r\n        //bg.height = game.world.height;\r\n\r\n        this.game.stage.backgroundColor='#d5dfef';\r\n\r\n        // Keyboard shortcuts\r\n/*        var kEnter = game.input.keyboard.addKey(Phaser.Keyboard.ENTER);\r\n        kEnter.onDown.add(function() {director.commitWord(); });\r\n*/\r\n        log.info(\"Level initialization complete.\");\r\n\r\n        game.debug.reset();\r\n    }\r\n\r\n    preload() {\r\n        this.game.time.advancedTiming = true;\r\n        this.game.time.desiredFps = 120;\r\n    }\r\n\r\n    create() {\r\n\r\n    }\r\n\r\n    update() {\r\n\r\n    }\r\n\r\n    render() {\r\n        if (this.debugMode) {\r\n            this.debug.render();\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport default Play;"
  ]
}